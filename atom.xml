<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TedYin&#39;s Blog</title>
  
  <subtitle>快乐比生命更重要</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tedyin.github.io/"/>
  <updated>2017-11-23T02:28:12.000Z</updated>
  <id>http://tedyin.github.io/</id>
  
  <author>
    <name>TedYin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Google AutoValue 自动生成代码</title>
    <link href="http://tedyin.github.io/2016/04/11/auto-value/"/>
    <id>http://tedyin.github.io/2016/04/11/auto-value/</id>
    <published>2016-04-11T15:25:19.000Z</published>
    <updated>2017-11-23T02:28:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载请注明出处：<a href="http://tedyin.github.io/2016/04/11/auto-value/">http://tedyin.github.io/2016/04/11/auto-value/</a></p></blockquote><p>在<code>Java</code>中通常定义一个模型类时，需要定义一堆不同类型的成员变量，而且为了满足面向对象的基本特征，又要定义一堆相应的<code>Getter</code>和<code>Setter</code>等方法，这个过程是非常枯燥的要写一堆样板代码。虽然现在 IDE 可以很好的帮我们生成这些样板代码，但是如果看到一个模型类里面有这么一堆的方法，总觉是会觉得不够清晰。</p><blockquote><p>我只想知道这个模型有哪些属性，以及特殊的方法，并不想知道大家都有的东西，你却非要让我看。。。</p></blockquote><p>好了，现在有办法可以解决这个问题了，使用 Google 开源的 <a href="https://github.com/google/auto/" target="_blank" rel="noopener">AutoValue</a> 就可以解决上述烦恼，而且最近<code>AutoValue</code>项目支持了大家期待已久的<code>Extension API</code>，使得<code>AutoValue</code>更加灵活，至于这个<code>Extension API</code>是干啥的后面会讲到，现在暂时不用去关心他。</p><a id="more"></a><h2 id="普通的-Java-模型"><a href="#普通的-Java-模型" class="headerlink" title="普通的 Java 模型"></a>普通的 Java 模型</h2><p>我们这里举个故事(Story)的例子，一个故事模型拥有一个<code>id</code>，以及一个<code>title</code>。下面我们来看下用<code>Java</code>代码来表示该模型的写法。</p><h3 id="不太严谨的写法"><a href="#不太严谨的写法" class="headerlink" title="不太严谨的写法"></a>不太严谨的写法</h3><p>我们先来看下一般情况下我们是怎么定义这个 POJO 的业务模型的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Story</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">public</span> String title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的写法非常简单，不过有些情况下可能会有问题，比如对象比较时，而且也不符合封装的要求，不过一般情况下业务逻辑简单，还处在快速迭代的时候这样写也没什么问题，而且重点是他 <strong>只有4行代码！</strong></p><h3 id="比较规范的写法"><a href="#比较规范的写法" class="headerlink" title="比较规范的写法"></a>比较规范的写法</h3><p>下面看下正常情况下的写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Story</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Story</span><span class="params">(<span class="keyword">int</span> id, String title)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">title</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样写符合了面向对象的基本特征<code>封装</code>的要求,但是如果这个<code>Story</code>是在列表或者集合中有用到比较的时候，这么写是有问题的，应该继续重载<code>hashCode()</code>和<code>equals()</code>方法，如果有特殊格式的输出，还得重载<code>toString()</code>方法。</p><p>把这些东西都补全的写法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Story</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Story</span><span class="params">(<span class="keyword">int</span> id, String title)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">title</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id + title;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">7</span>;</span><br><span class="line">    hash = <span class="number">31</span> * hash + <span class="keyword">this</span>.id;</span><br><span class="line">    hash = <span class="number">31</span> * hash + (<span class="keyword">null</span> == title ? <span class="number">0</span> : title.hashCode());</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || !(o <span class="keyword">instanceof</span> Stroy)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Story s = (Story) o;</span><br><span class="line">    <span class="keyword">if</span> (s.id != s.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> s.title.equals(s.title);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的版本是一个比较完整的模型写法，相比起最初的版本，代码多了不少从原来的<code>4</code>行变成了现在的<code>39</code>行！<br>OMG！现在的版本还没有实现<code>Parcelable</code>接口，如果再在他的基础上实现<code>Parcelable</code>接口，那代码又得增加十几行，想想都心累啊。</p><h2 id="使用AutoValue拯救你的代码"><a href="#使用AutoValue拯救你的代码" class="headerlink" title="使用AutoValue拯救你的代码"></a>使用AutoValue拯救你的代码</h2><p>我本想要一个只有几行的模型类，但是出于各方面原因，我得到了一个几十行代码的模型类，为了解决这个问题伟大的<code>Google</code>开发了<code>AutoValue</code>这个库来自动生成这些样板代码，解放我们的双手，让我们把更多的精力放在更重要的事情上。</p><h3 id="使用AutoValue"><a href="#使用AutoValue" class="headerlink" title="使用AutoValue"></a>使用AutoValue</h3><p>使用方法很简单，只需要在你的项目中引入<code>AutoValue</code>的插件即可<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">dependencies</span> &#123;</span><br><span class="line">  <span class="attribute">apt</span> <span class="string">'com.google.auto.value:auto-value:1.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在代码中使用<code>@AutoValue</code>注解来指定哪个类需要生成类似于上面的样板代码。下面我们使用<code>AutoValue</code>来重新实现一下<code>Story</code>模型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Story</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">title</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@AutoValue</code>注解后，<code>AutoValue</code>会生成一个<code>AutoValue_你的类名</code>为名称的类，这个类是<code>包级私有</code>的，他里面有私有的成员变量，对应的构造函数，以及重写的<code>hashCode()</code>、<code>equals()</code>和<code>toString()</code>方法，而且这些方法都是被测试过的确保无误的，你可以放心的使用。由于这个生成的子类是<code>包级私有</code>的，所以这里在给<code>Story</code>提供构造方法的时候需要提供一个静态的构造方法,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Story</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">title</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Story <span class="title">create</span><span class="params">(<span class="keyword">int</span> id, String title)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> AutoValue_Story(id,title);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，使用AutoValue后，这短短几行代码就完成了上面几十行代码干的事，而且这样生成出来的代码都是被测试过准确无误的，这也避免了一些因为手误或者逻辑错误导致的BUG的产生，是不是很爽？必须很爽啊！</p><p>But… 我们要更爽一点！</p><h2 id="AutoValue-Extension-API"><a href="#AutoValue-Extension-API" class="headerlink" title="AutoValue Extension API"></a>AutoValue Extension API</h2><p>大家注意到没有上面使用<code>AutoValue</code>实现的<code>Story</code>模型并没有实现<code>Parcelable</code>接口，那如果要实现这个接口是不是又得一堆代码呢？当然不会，因为我们有<code>Extension API</code>，因为有了他我们可以使用基于他实现出来的<a href="https://github.com/rharter/auto-value-parcel" target="_blank" rel="noopener">AutoValue: Parcel Extension</a>来实现<code>Parcelable</code>接口。</p><h3 id="使用-Parcel-Extension-实现-Parcelable-接口"><a href="#使用-Parcel-Extension-实现-Parcelable-接口" class="headerlink" title="使用 Parcel Extension 实现 Parcelable 接口"></a>使用 Parcel Extension 实现 Parcelable 接口</h3><p>首先我们需要在项目中集成 <code>AutoValue Parcel Extension</code><br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="attribute">provided 'com.google.auto.value</span>:auto-value:1.2'</span><br><span class="line">  apt 'com<span class="variable">.google</span><span class="variable">.auto</span><span class="variable">.value</span>:auto-value:1.2'</span><br><span class="line">  apt 'com<span class="variable">.ryanharter</span><span class="variable">.auto</span><span class="variable">.value</span>:auto-value-parcel:0.2.1'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再在代码中加入<code>implements Parcelable</code>即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Story</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">title</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Story <span class="title">create</span><span class="params">(<span class="keyword">int</span> id, String title)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> AutoValue_Story(id,title);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是已经体会到了<code>AutoValue Extension</code>的厉害了？反正我是觉得碉堡了！<br>有了这个扩展功能，能干的事情就多了，常规的像对象序列化成 JSON 字符串，将 JSON 字符串解析成对象等这些事情就不用自己再去动手去写了，直接用<code>AutoValue</code>生成就可以了，再也不用去写那些<code>toJson()</code>和<code>fromJson</code>之类的方法了，真是爽歪歪啊！</p><h3 id="更多的-AutoValue-Extension"><a href="#更多的-AutoValue-Extension" class="headerlink" title="更多的 AutoValue Extension"></a>更多的 AutoValue Extension</h3><p>目前已经有人实现了一些 AutoValue 的扩展了，具体的可以看<a href="http://search.maven.org/#search%7Cga%7C1%7Cauto-value" target="_blank" rel="noopener">这里</a>。如果这些都无法满足你的需求，那你可以使用 <code>AutoValue Extension API</code>去自己实现一个 AutoValue 的扩展。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://ryanharter.com/blog/2016/03/22/autovalue/" target="_blank" rel="noopener">An Introduction to AutoValue</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;http://tedyin.github.io/2016/04/11/auto-value/&quot;&gt;http://tedyin.github.io/2016/04/11/auto-value/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;Java&lt;/code&gt;中通常定义一个模型类时，需要定义一堆不同类型的成员变量，而且为了满足面向对象的基本特征，又要定义一堆相应的&lt;code&gt;Getter&lt;/code&gt;和&lt;code&gt;Setter&lt;/code&gt;等方法，这个过程是非常枯燥的要写一堆样板代码。虽然现在 IDE 可以很好的帮我们生成这些样板代码，但是如果看到一个模型类里面有这么一堆的方法，总觉是会觉得不够清晰。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我只想知道这个模型有哪些属性，以及特殊的方法，并不想知道大家都有的东西，你却非要让我看。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，现在有办法可以解决这个问题了，使用 Google 开源的 &lt;a href=&quot;https://github.com/google/auto/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AutoValue&lt;/a&gt; 就可以解决上述烦恼，而且最近&lt;code&gt;AutoValue&lt;/code&gt;项目支持了大家期待已久的&lt;code&gt;Extension API&lt;/code&gt;，使得&lt;code&gt;AutoValue&lt;/code&gt;更加灵活，至于这个&lt;code&gt;Extension API&lt;/code&gt;是干啥的后面会讲到，现在暂时不用去关心他。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://tedyin.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="java" scheme="http://tedyin.github.io/tags/java/"/>
    
      <category term="android" scheme="http://tedyin.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习技巧笔记</title>
    <link href="http://tedyin.github.io/2016/03/27/design-pattern-skills/"/>
    <id>http://tedyin.github.io/2016/03/27/design-pattern-skills/</id>
    <published>2016-03-27T12:14:07.000Z</published>
    <updated>2017-11-23T02:28:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载请注明出处：<a href="http://tedyin.github.io/2016/03/27/design-pattern-skills/">http://tedyin.github.io/2016/03/27/design-pattern-skills/</a></p></blockquote><h3 id="设计模式是什么"><a href="#设计模式是什么" class="headerlink" title="设计模式是什么"></a>设计模式是什么</h3><p>设计模式是对特定问题经过无数次的经验总结之后，提出的能够解决它的优雅的方案。</p><h3 id="重构是什么"><a href="#重构是什么" class="headerlink" title="重构是什么"></a>重构是什么</h3><p>重构就是在不改变软件系统外部行为的前提下，改善它的内部结构。</p><a id="more"></a><h3 id="什么是结构化方法"><a href="#什么是结构化方法" class="headerlink" title="什么是结构化方法"></a>什么是结构化方法</h3><p>结构化的方法是以具体的功能为核心来组织程序的结构，它的封装度仅为1级(仅仅封装了完成职责的方法)，即仅有对于特定的功能的封装（函数），扩展性很差，很难适应需求的变化。面向对象的方法正是在这一点上优于结构化的方法。在面向对象领域，是以对象来组成程序结构的，一个对象有自己的职责，通过对象间的交互来完成系统的功能，这使得它的封装度至少为2级（封装了方法+数据），即封装了为完成自己职责的方法和数据。另外面向对象的方法还支持更高层次的封装，比如：通过对不同的具体对象的共同的概念行为进行总结概括，我们可以达到3级的封装度 － 抽象的类（在Java中就是接口）。封装的层次越高，抽象的层次就越高，使得设计、代码有越高的弹性，越容易适应变化。</p><p>通过对不同的具体对象的共性进行总结概括，我们可以达到3级的封装度 － 抽象的类。</p><p>封装的层次越高，抽象的层次就越高，设计和代码的弹性就越高，就越容易适应需求的变化。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li>面向对象范式</li><li>面向对象原则（SOLID）</li><li>重新认识面向对象，了解这种思想</li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>面向对象的特点：封装，继承，多态。在写类时必须遵守这三点，如何去评价一个类的好坏，就从这三点出发，在写类之前就用这三点过一遍，保证这三点都背遵守。</li><li><p>封装：一切不需要被外界知道的东西，都要封装在内部。</p></li><li><p>继承：</p></li></ul><ol><li>切记设计模式不只是一种方法和技术，更是一种思想和方法论。他是一种思想！！</li><li>学习设计模式最主要的目的就是要建立面向对象的思想，尽可能的面向接口编程，低耦合、高内聚，使你设计的程序尽可能的复用。</li><li>在学习设计模式的过程中，应该更加注意设计模式背后的东西，即具体设计模式所共有的的一些优秀的指导原则：<br>  a. 发现变化，封装变化。<br>  b. 优先使用组合，而不是继承。</li><li>设计模式并不仅仅是一个有关特定问题的解决方案这个结果，它的意图以及它的动机往往更重要，因为一旦我们理解了一个设计模式的意图、动机，那么在设计过程中，就很容易的发现适用于我们自己的设计模式，从而大大简化设计工作，并且可以得到一个比较理想的设计方案。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;http://tedyin.github.io/2016/03/27/design-pattern-skills/&quot;&gt;http://tedyin.github.io/2016/03/27/design-pattern-skills/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;设计模式是什么&quot;&gt;&lt;a href=&quot;#设计模式是什么&quot; class=&quot;headerlink&quot; title=&quot;设计模式是什么&quot;&gt;&lt;/a&gt;设计模式是什么&lt;/h3&gt;&lt;p&gt;设计模式是对特定问题经过无数次的经验总结之后，提出的能够解决它的优雅的方案。&lt;/p&gt;
&lt;h3 id=&quot;重构是什么&quot;&gt;&lt;a href=&quot;#重构是什么&quot; class=&quot;headerlink&quot; title=&quot;重构是什么&quot;&gt;&lt;/a&gt;重构是什么&lt;/h3&gt;&lt;p&gt;重构就是在不改变软件系统外部行为的前提下，改善它的内部结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://tedyin.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://tedyin.github.io/2016/03/20/adapter-pattern/"/>
    <id>http://tedyin.github.io/2016/03/20/adapter-pattern/</id>
    <published>2016-03-20T14:13:09.000Z</published>
    <updated>2017-11-23T02:28:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载请注明出处：<a href="http://tedyin.github.io/2016/03/20/adapter-pattern/">http://tedyin.github.io/2016/03/20/adapter-pattern/</a></p></blockquote><p>这次跟大家分享一下我对适配器模式的理解。</p><p>适配器模式的定义:</p><blockquote><p>将一个类的接口转换成用户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类，可以一起工作了。</p></blockquote><p>举个我们日常生活中的例子:</p><p>有一部移动电源，有一部iphone一部android手机，需要充电使用普通的Usb线就可以给android手机充电，而在给iphone充电的时候必须使用适配iphone的万能转接头才能充电。</p><p>iphone和android就相当于两个不兼容的接口，转接头就相当于一个适配器，他使得iphone和android手机都能充电了。</p><a id="more"></a><p>在我们的项目中可以这样是用适配器模式:</p><p>假如我们开发一个发发动态的功能，第一版要求可以发送文字，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISendTextPost</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTextPost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendTextPost</span> <span class="keyword">implements</span> <span class="title">ISendTextPost</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> sendTextPost&#123;</span><br><span class="line">        <span class="comment">//发送文字动态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现方式如上所述，很简单。如果第二版要求既可以发图片也可以发文字动态，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISendPicturePost</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTextPost</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">pubiic <span class="keyword">void</span> <span class="title">sendPicturePost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假如发文字和图片是这样的~~</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendPicturePost</span> <span class="keyword">implements</span> <span class="title">ISendPicturePost</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> sendTextPost&#123;</span><br><span class="line">        <span class="comment">//发送文字动态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> sendPicturePost&#123;</span><br><span class="line">        <span class="comment">//发送图片动态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述这样实现可以吗？答案是必须不行的，因为发送文字的方法之前已经实现了，完全没必要再去实现一次。如果重复的方法有很多呢，估计都想砸键盘了。</p><p>对于这种接口不兼容的问题，使用适配器模式可以很好的解决：</p><p>适配器模式的模型如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户所需功能接口 target1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITarget1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTarget1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//target1实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target1Impl</span> <span class="keyword">implements</span> <span class="title">ITarget1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTarget1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//做A事情</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户所需功能接口 target2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITarget2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTarget2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//target2实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target2Imp</span> <span class="keyword">implements</span> <span class="title">ITarget2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTarget2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//做B事情</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">ITarget1</span>, <span class="title">ITarget2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITarget1 target1;</span><br><span class="line">    <span class="keyword">private</span> ITarget2 target2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(ITarget1 target1,ITarget2 target2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target1 = target1;</span><br><span class="line">        <span class="keyword">this</span>.target2 = target2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">target1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//做A事情</span></span><br><span class="line">        target1.doTarget1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTarget2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//做B事情</span></span><br><span class="line">        target2.doTarget2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Sting[] args)</span></span>&#123;</span><br><span class="line">        ITarget1 target1 = <span class="keyword">new</span> Target1Impl();</span><br><span class="line">        ITarget2 target2 = <span class="keyword">new</span> Target1Imp2();</span><br><span class="line"></span><br><span class="line">        Adapter adapter = <span class="keyword">new</span> Adapter(target1,target2);</span><br><span class="line">        adapter.doTarget1();</span><br><span class="line">        adapter.doTarget2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是使用适配器的实现方式。在上述的实现方式中，<code>target1</code>和<code>target2</code>都是业务层面的接口，他们有不同的业务功能，对于客户端来说，调用<code>target1</code>接口时很正常，但是要兼容<code>target2</code>的功能的时候，就需要有一个实现了<code>target1</code>功能，并且兼容了<code>target2</code>功能的类，<code>Adapter</code>就是这样的一个类，他就是一个转换器，兼容不同的接口来实现功能。</p><p>在上面的实现中，实质上是使用了<code>对象组合</code>来实现业务功能的兼容。使用<code>Adapter</code>可使得已有功能复用，加快开发效率，减少维护成本，在<code>Adapter</code>中也可以加入一些自己实现的公用方法，这样可以使得Adapter的功能更强大。</p><p>但是要注意的一点是，在一个系统中不应该过多的使用<code>Adapter模式</code>，使用过多，会使得系统变得比较凌乱，不好把握，本来明明调的是A接口但是返回的是B结果，因此在使用适配器模式时要记住这一点。</p><blockquote><p>适配器模式的最重要的一点就是，对象组合，转换匹配，复用功能。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;http://tedyin.github.io/2016/03/20/adapter-pattern/&quot;&gt;http://tedyin.github.io/2016/03/20/adapter-pattern/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这次跟大家分享一下我对适配器模式的理解。&lt;/p&gt;
&lt;p&gt;适配器模式的定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将一个类的接口转换成用户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类，可以一起工作了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个我们日常生活中的例子:&lt;/p&gt;
&lt;p&gt;有一部移动电源，有一部iphone一部android手机，需要充电使用普通的Usb线就可以给android手机充电，而在给iphone充电的时候必须使用适配iphone的万能转接头才能充电。&lt;/p&gt;
&lt;p&gt;iphone和android就相当于两个不兼容的接口，转接头就相当于一个适配器，他使得iphone和android手机都能充电了。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://tedyin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://tedyin.github.io/tags/java/"/>
    
      <category term="面向对象设计" scheme="http://tedyin.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>你真的会用单例模式吗</title>
    <link href="http://tedyin.github.io/2016/03/13/singlton-pattern/"/>
    <id>http://tedyin.github.io/2016/03/13/singlton-pattern/</id>
    <published>2016-03-13T06:47:18.000Z</published>
    <updated>2017-11-23T02:28:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载请注明出处：<a href="http://tedyin.github.io/2016/03/13/singlton-pattern/">http://tedyin.github.io/2016/03/13/singlton-pattern/</a></p></blockquote><p>今天给大家介绍一下<code>单例模式</code>,就是这个出场率特别高的模式，是个程序员基本都用过他，没用过至少也都知道他。可是我们真的了解他吗？</p><p>单例模式通常的实现方式分为以下两种：</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Do something ...</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>饿汉式</code>是最简单的实现方式，这种实现方式适合那些在初始化时就要用到单例的情况，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存非常小的时候这种方式是比较合适的，可以直接在应用启动时加载并初始化。<br>但是，如果单例初始化的操作耗时比较长而应用对于启动速度又有要求，或者单例的占用内存比较大，再或者单例只是在某个特定场景的情况下才会被使用，而一般情况下是不会使用时，使用<code>饿汉式</code>的单例模式就是不合适的，这时候就需要用到<code>懒汉式</code>的方式去按需延迟加载单例。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Do something ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>懒汉式</code>与<code>饿汉式</code>的最大区别就是将单例的初始化操作，延迟到需要的时候才进行，这样做在某些场合中有很大用处。比如某个单例用的次数不是很多，但是这个单例提供的功能又非常复杂，而且加载和初始化要消耗大量的资源，这个时候使用<code>懒汉式</code>就是非常不错的选择。</p><h3 id="多线程下的单例模式"><a href="#多线程下的单例模式" class="headerlink" title="多线程下的单例模式"></a>多线程下的单例模式</h3><p>上面介绍了一些单例模式的基本应用方法，但是上面所说的那些使用方式都是有一个隐含的前提，那就是他们都是应用在单线程条件下，一旦换成了多线程就有出错的风险。<br>如果在多线程的情况下，<code>饿汉式</code>不会出现问题，因为JVM只会加载一次单利类，但是<code>懒汉式</code>可能就会出现重复创建单利对象的问题。为什么会有这样的问题呢？因为<code>懒汉式</code>在创建单例时是 <strong>线程不安全的</strong>，多个线程可能会并发调用他的<code>newInstance</code>方法导致多个线程可能会创建多份相同的单例出来。</p><p>那有没有办法，使<code>饿汉式</code>的单利模式也是线程安全的呢？答案肯定是有的，大家通常会使用加同步锁的方式去实现，但是这样实现起来比较麻烦。那么有没有更好的实现方式呢？能问这个问题那必须是有的，否则就得打脸了。 <em>我们可以利用JVM的类加载机制去实现</em>。在很多情况下JVM已经为我们提供了同步控制，比如：</p><ul><li>在<code>static{}</code>区块中初始化的数据</li><li>访问<code>final</code>字段时</li><li>…</li><li>等等</li></ul><p>因为在JVM进行类加载的时候他会保证数据是同步的，我们可以这样实现：</p><blockquote><p>采用内部类，在这个内部类里面去创建对象实例。这样的话，只要应用中不使用内部类 JVM 就不会去加载这个单例类，也就不会创建单例对象，从而实现<code>懒汉式</code>的延迟加载和线程安全。</p></blockquote><p>实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//内部类，在装载该内部类时才会去创建单利对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样实现出来的单例类就是线程安全的，麻麻再也不用担心我的单例不是单例了。</p><h3 id="使用枚举实现单例模式"><a href="#使用枚举实现单例模式" class="headerlink" title="使用枚举实现单例模式"></a>使用枚举实现单例模式</h3><p>除了上述的单例模式的实现方式外，我们还可以通过枚举类来实现单利模式，这也是<code>Effective Java</code>中推荐的方式。</p><p>使用枚举类型实现单例模式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    <span class="comment">//定义一个枚举的元素，它就是Singleton的一个实例</span></span><br><span class="line">    instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// do something ...</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用枚举实现是不是更简单呢？枚举方式实现的单例模式也是线程安全的，所以大家不用担心多线程问题，可以大胆去用。</p><p>以上就是单例模式的使用，现在完全可以说，你真的会用单例模式了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;http://tedyin.github.io/2016/03/13/singlton-pattern/&quot;&gt;http://tedyin.github.io/2016/03/13/singlton-pattern/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天给大家介绍一下&lt;code&gt;单例模式&lt;/code&gt;,就是这个出场率特别高的模式，是个程序员基本都用过他，没用过至少也都知道他。可是我们真的了解他吗？&lt;/p&gt;
&lt;p&gt;单例模式通常的实现方式分为以下两种：&lt;/p&gt;
&lt;h3 id=&quot;饿汉式&quot;&gt;&lt;a href=&quot;#饿汉式&quot; class=&quot;headerlink&quot; title=&quot;饿汉式&quot;&gt;&lt;/a&gt;饿汉式&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;comment&quot;&gt;// Do something ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://tedyin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://tedyin.github.io/tags/java/"/>
    
      <category term="面向对象设计" scheme="http://tedyin.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>让你的Rails应用更加健壮的5种姿势『译』</title>
    <link href="http://tedyin.github.io/2016/03/06/five-practices-for-robust-ruby-on-rails-applications/"/>
    <id>http://tedyin.github.io/2016/03/06/five-practices-for-robust-ruby-on-rails-applications/</id>
    <published>2016-03-06T09:58:43.000Z</published>
    <updated>2017-11-23T02:28:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://brewhouse.io/2016/02/26/five-practices-for-robust-ruby-on-rails-applications.html" target="_blank" rel="noopener">原文链接: Five Practices for Robust Ruby on Rails Applications</a><br>转载请注明出处：<a href="http://tedyin.github.io/2016/03/06/five-practices-for-robust-ruby-on-rails-applications/">http://tedyin.github.io/2016/03/06/five-practices-for-robust-ruby-on-rails-applications/</a></p></blockquote><p>无论什么时候，当我发现项目里面存在 bug 或者数据不一致，但却又很难找到是哪里出了问题时，我总是会感叹：“他们(the developer)只需要再多敲几下键盘，这些事情就不会发生了。”</p><p>在<a href="http://brewhouse.io/" target="_blank" rel="noopener">Brewhouse</a>的工作中，我们会应用下面5种最佳实践，让我们的 Rails 应用更加健壮。因为这些方法可以让代码在遇到问题时，可以尽早地、明确地、快速地的抛出问题，告诉我们哪里出错了。我们可以通过捕捉这些错误信息来确保我们所有的数据和操作都是正确有效的。</p><a id="more"></a><h2 id="使用-Hash-fetch-方法去处理‘有问题’的-hash-对象"><a href="#使用-Hash-fetch-方法去处理‘有问题’的-hash-对象" class="headerlink" title="使用 Hash#fetch 方法去处理‘有问题’的 hash 对象"></a>使用 Hash#fetch 方法去处理‘有问题’的 hash 对象</h2><p><code>unexpected method &#39;upcase&#39; for nil…</code> 这样的错误，我们经常会遇到。无论什么时候当你去遍历一个<code>hash</code>对象，如果你希望这个<code>hash</code>对象中所有的<code>key</code>都存在，你最好是使用<code>fetch</code>方法去代替<code>[]</code>方法。<code>fetch()</code>方法在遇到<code>key</code>不存在的情况时会抛出异常，因此你就无法再传入一个有问题的<code>hash</code>对象了，也就不可能出现一些奇怪的 bug 了。</p><h2 id="使用-case-…-else-raise-去捕获异常数据"><a href="#使用-case-…-else-raise-去捕获异常数据" class="headerlink" title="使用 case … else raise 去捕获异常数据"></a>使用 case … else raise 去捕获异常数据</h2><p>最好是在所有的<code>case</code>条件选择语句中加入<code>else raise</code>语句，来处理一些你预想之外的情况。当你的方法接收到一些你预想之外的数据时，<strong>我想你肯定是想知道这些是什么数据，而不是说忽略这些数据，而让代码继续执行</strong>。因此建议使用<code>case ... else raise</code>!</p><h2 id="使用-ActiveRecord-的-‘-’-方法，让失败的操作自己说话"><a href="#使用-ActiveRecord-的-‘-’-方法，让失败的操作自己说话" class="headerlink" title="使用 ActiveRecord 的 ‘!’ 方法，让失败的操作自己说话"></a>使用 ActiveRecord 的 ‘!’ 方法，让失败的操作自己说话</h2><p>对于每个公司来说，数据通常都是非常重要的资产。如果在对数据进行持久化或者其他错作时失败了，但是这些失败的操作是悄悄发生的我们并不知道，那么这会是一件很危险的事情，将会对我们的数据造成严重的危害。因此无论什么时候，当你不希望某些操作失败时你却不知道的话，建议是用<code>create!</code>，<code>update!</code>和<code>destroy!</code>方法，在操作失败的时候他们会抛出异常，来告诉你操作失败了。这额外的一个字符<code>!</code>将会让你避免去处理麻烦的数据不一致等奇奇怪怪的问题。</p><p>我们一般都会写测试代码，但是我们一定要确保测试代码在<code>setup</code>时是正确的，而且如果测试在<code>setup</code>时是错误的，那一定要抛出异常让我们知道，因为没有比使用一个错误的<code>setup</code>跑出正确的测试结果更让人蛋疼的事情了，这样的代码一旦上线，那后果你懂的…</p><p>除了上面说的，在执行的多个SQL调用时，使用事务将那些调用包起来处理，可以避免你的操作导致数据处于不一致的状态，或者是半吊子的状态。</p><blockquote><p>译者注：确实如此，曾经有一次我在处理数据的时候，就是没有注意这些导致造成了数据破坏，幸亏当时的数据有备份，才没有导致大的问题。</p></blockquote><h2 id="使用-ActiveRecord-的-validate-相关方法来动态校验你的数据"><a href="#使用-ActiveRecord-的-validate-相关方法来动态校验你的数据" class="headerlink" title="使用 ActiveRecord 的 validate 相关方法来动态校验你的数据"></a>使用 ActiveRecord 的 validate 相关方法来动态校验你的数据</h2><p>使用 ActiveRecord 的 validate 相关的方法，并且使用带有<code>!</code>的方法来做校验方法，将会是一个很好的方式去确保你在持久化数据时不会出错。举个例子：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span> &lt; ActiveRecord::Model</span></span><br><span class="line">  validates <span class="symbol">:author</span>, <span class="symbol">:blog</span>, <span class="symbol">presence:</span> <span class="literal">true</span></span><br><span class="line">  validates <span class="symbol">:published_by</span>, <span class="symbol">presence:</span> <span class="literal">true</span>, <span class="symbol">if:</span> <span class="symbol">:published?</span></span><br><span class="line">  validates <span class="symbol">:comment_count</span>, <span class="symbol">numericality:</span> &#123; <span class="symbol">greater_or_equal_to:</span> <span class="number">0</span> &#125;</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="使用数据库约束来确保你的数据的一致性"><a href="#使用数据库约束来确保你的数据的一致性" class="headerlink" title="使用数据库约束来确保你的数据的一致性"></a>使用数据库约束来确保你的数据的一致性</h2><p>你的数据库是你最好的朋友，他能够帮你保存你的数据，并且确保你的数据不出现重复和“孤儿记录”的问题。</p><p>一般情况下，你应该为你的数据库中的大多数字段设置他们默认不为空，也就是<code>null: false</code>。<br>你是否知道 Rails 中的 <code>has_one</code> 约束，在数据的创建时不会起到唯一性约束作用呢？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line">  has_one <span class="symbol">:account_settings</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">account = Account.create!</span><br><span class="line">account.create_account_settings!</span><br><span class="line">account.create_account_settings!</span><br><span class="line">account.create_account_settings!</span><br><span class="line"></span><br><span class="line">account.account_settings</span><br><span class="line"> <span class="comment"># =&gt; one of the three account settings you've created... -_-</span></span><br></pre></td></tr></table></figure><p>如果想让你的数据不出现重复，最好的方式是给你的数据添加唯一索引。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_index <span class="symbol">:account_settings</span>, <span class="symbol">:account_id</span>, <span class="symbol">unique:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>这样做之后，如果你尝试去创建重复的记录时，数据库就会抛出异常，去阻止你创建重复数据。</p><p>我们每一个人都不会想存储一些“孤儿记录”在数据库中。但是如何去解决这些“孤儿记录”呢？使用外键是可以很好的帮你解决这个问题，在这里我推荐大家使用<a href="https://github.com/SchemaPlus/schema_auto_foreign_keys" target="_blank" rel="noopener">schema_auto_foreign_keys</a>这个 gem 去为你的相关的表自动添加外键约束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多写几个字母就可以帮我们避免处理数据不一致的麻烦问题，也会大大减少我们代码的 bug 率，提高我们的工作效率。记住，使用<code>!</code>，<code>raise</code>，<code>validate</code>和<code>数据库约束</code>去强化你的代码，使你的代码更加强壮。你的同事会感谢你，说不定以后当你在次翻看你的代码的时，你会觉得当时做的真好，让你在后来避免了很多不必要的麻烦。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://brewhouse.io/2016/02/26/five-practices-for-robust-ruby-on-rails-applications.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接: Five Practices for Robust Ruby on Rails Applications&lt;/a&gt;&lt;br&gt;转载请注明出处：&lt;a href=&quot;http://tedyin.github.io/2016/03/06/five-practices-for-robust-ruby-on-rails-applications/&quot;&gt;http://tedyin.github.io/2016/03/06/five-practices-for-robust-ruby-on-rails-applications/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无论什么时候，当我发现项目里面存在 bug 或者数据不一致，但却又很难找到是哪里出了问题时，我总是会感叹：“他们(the developer)只需要再多敲几下键盘，这些事情就不会发生了。”&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://brewhouse.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Brewhouse&lt;/a&gt;的工作中，我们会应用下面5种最佳实践，让我们的 Rails 应用更加健壮。因为这些方法可以让代码在遇到问题时，可以尽早地、明确地、快速地的抛出问题，告诉我们哪里出错了。我们可以通过捕捉这些错误信息来确保我们所有的数据和操作都是正确有效的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://tedyin.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="ruby on rails" scheme="http://tedyin.github.io/tags/ruby-on-rails/"/>
    
  </entry>
  
  <entry>
    <title>SOLID 原则在Ruby中的应用『译』</title>
    <link href="http://tedyin.github.io/2016/02/27/solid-principles-in-ruby/"/>
    <id>http://tedyin.github.io/2016/02/27/solid-principles-in-ruby/</id>
    <published>2016-02-27T15:27:00.000Z</published>
    <updated>2017-11-23T02:28:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://eftimov.net/solid-principles" target="_blank" rel="noopener">原文链接: SOLID Principles in Ruby</a><br>转载请注明出处：<a href="http://tedyin.github.io/2016/02/27/solid-principles-in-ruby/">http://tedyin.github.io/2016/02/27/solid-principles-in-ruby/</a></p></blockquote><p>作为一名程序员无论你的水平高低，你都会想写出一手优秀的代码，但是想写优秀的代码并不容易，因此怎样才能提高我们的代码质量呢？下面来看下我们今天的主角 <code>SOLID 原则</code><br><a id="more"></a></p><h2 id="SOLID-原则是什么"><a href="#SOLID-原则是什么" class="headerlink" title="SOLID 原则是什么"></a>SOLID 原则是什么</h2><p>SOLID 不是一个原则，他是一组面向对象设计原则的简称，他代表下面5种设计原则:</p><ul><li><strong>S</strong> ingle Responsibility Principle <em>单一职责原则</em></li><li><strong>O</strong> pen/Closed Principle <em>开闭原则</em></li><li><strong>L</strong> iskov Substitution Principle <em>里氏替换原则</em></li><li><strong>I</strong> nterface Segregation Principle <em>接口分离原则</em></li><li><strong>D</strong> ependency Inversion Principle <em>依赖倒置原则</em></li></ul><p>以上就是SOLID中的5种面向对象设计原则，下面分别看看他们具体指的是什么。</p><h3 id="单一职责原则-SPR"><a href="#单一职责原则-SPR" class="headerlink" title="单一职责原则(SPR)"></a>单一职责原则(SPR)</h3><p>在我看来这个是最简单的一个设计原则，<code>SPR</code>的说明如下：</p><blockquote><p>每一个类或则方法都应该有且仅有一个职责，而且他的这个职责应该被完全封装在这个类里面。</p></blockquote><p>如何去判断你的代码是否符合这一原则的最好方式就是去问问自己：</p><blockquote><p>这个类或者方法到底做了什么？</p></blockquote><p>如果他干了不只一件事情的话，那么他就违反了<code>SPR</code>原则。下面来看一个<code>Student</code>类，每个<code>Student</code>对象都有<code>grades</code>属性。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:first_term_home_work</span>, <span class="symbol">:first_term_test</span>,</span><br><span class="line">    <span class="symbol">:first_term_paper</span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:second_term_home_work</span>, <span class="symbol">:second_term_test</span>,</span><br><span class="line">    <span class="symbol">:second_term_paper</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">first_term_grade</span></span></span><br><span class="line">    (first_term_home_work + first_term_test + first_term_paper) / <span class="number">3</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">second_term_grade</span></span></span><br><span class="line">    (second_term_home_work + second_term_test + second_term_paper) / <span class="number">3</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>也许有些人已经意识到了，上面的写法是错误的，也许有些人还没有感觉到。不管有没有意识到，上面的代码显然是没有循序<code>SPR</code>原则的，原因就是 Student 类拥有计算每个学期平均分的逻辑，但是<code>Student</code>类是用来封装关于学生信息的而不是用来计算分数的，计算分数的逻辑应当放在<code>Grade</code>类中才对。下面我们遵循<code>SPR</code>原则重构一下代码，重构后的代码如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @terms = [</span><br><span class="line">      Grade.new(<span class="symbol">:first</span>),</span><br><span class="line">      Grade.new(<span class="symbol">:second</span>)</span><br><span class="line">      ]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">first_term_grade</span></span></span><br><span class="line">    term(<span class="symbol">:first</span>).grade</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">second_term_grade</span></span></span><br><span class="line">    term(<span class="symbol">:second</span>).grade</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">term</span> <span class="title">reference</span></span></span><br><span class="line">    @terms.find &#123;<span class="params">|term|</span> term.name == reference&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:name</span>, <span class="symbol">:home_work</span>, <span class="symbol">:test</span>, <span class="symbol">:paper</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(name)</span></span></span><br><span class="line">    @name      = name</span><br><span class="line">    @home_work = <span class="number">0</span></span><br><span class="line">    @test      = <span class="number">0</span></span><br><span class="line">    @paper     = <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">grade</span></span></span><br><span class="line">    (home_work + test + paper) / <span class="number">3</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>重构之后的代码<code>Student</code>类中的计算分数的逻辑移到了<code>Grade</code>类中，<code>Student</code>类中只有对<code>Grade</code>实例的引用。现在所有的类都遵循<code>SPR</code>原则，因为每个类都是职责单一的。</p><h3 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则(OCP)"></a>开闭原则(OCP)</h3><p>开闭原则的定义如下：</p><blockquote><p>一个类或者模块对扩展开放，对修改关闭。</p></blockquote><p>什么意思呢？他的意思就是：一旦一个类已经实现了当时的需求，他就不应该为了去实现接下来的需求而被修改。你是不是觉得这样做没有意义？那我们下面看个例子来说明一下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLogger</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @format_string = <span class="string">"%s: %s\n"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(msg)</span></span></span><br><span class="line">  STDOUT.write @format_string % [Time.now, msg]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>这是一个简单的logger类，他可以将把给定的msg和当时的时间通过<code>STDOUT</code>格式化输出出来。非常简单对吧，下面来测试一下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irb&gt; MyLogger.new.log(<span class="string">'test!'</span>)</span><br><span class="line">=&gt; <span class="number">2016</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">16</span><span class="symbol">:</span><span class="number">16</span><span class="symbol">:</span><span class="number">32</span> +<span class="number">0200</span>: test!</span><br></pre></td></tr></table></figure></p><p>测试OK，没什么问题，但是假如在以后的某一天，我们想改变一下输出的格式，想实现下面的日志格式<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; [LOG] <span class="number">2016</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">16</span><span class="symbol">:</span><span class="number">16</span><span class="symbol">:</span><span class="number">32</span> +<span class="number">0200</span>: test!</span><br></pre></td></tr></table></figure></p><p>怎么办呢？假如现在由一个不懂<code>OCP</code>原则的程序员来实现上述格式，实现的代码如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLogger</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @format_string = <span class="string">"[LOG] %s: %s\n"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>输出的结果如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irb&gt; MyLogger.new.log(<span class="string">'test!'</span>)</span><br><span class="line">=&gt; [LOG] <span class="number">2016</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">16</span><span class="symbol">:</span><span class="number">16</span><span class="symbol">:</span><span class="number">32</span> +<span class="number">0200</span>: test!</span><br></pre></td></tr></table></figure></p><p>输出的格式完全符合要求，一切都OK，但是这样做真的就对吗？<br>仔细想想，假如上面被修改的类是一个App中的核心类，对<code>format_string</code>方法的修改，可能会破坏那些依赖<code>MyLogger</code>类的方法使得他们不能正常的工作。也许在APP中存在许许多多的类都依赖刚才说的那些方法，但是现在我们修改了代码，破坏了这些类和方法。这就是在破坏<code>OCP</code>原则，这会导致灾难性的后果。</p><p>既然不遵循<code>OCP</code>原则会有很严重的问题，那么实现上面修改日志格式需求的正确姿势是什么呢？毫无疑问当然是<code>继承</code>或者<code>组合</code>！<br>我们来看看下面使用继承的例子：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewCoolLogger</span> &lt; MyLogger</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @format_string = <span class="string">"[LOG] %s: %s\n"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irb&gt; NewCoolLogger.new.log(<span class="string">'test!'</span>)</span><br><span class="line">=&gt; [LOG] <span class="number">2016</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">16</span><span class="symbol">:</span><span class="number">16</span><span class="symbol">:</span><span class="number">32</span> +<span class="number">0200</span>: test!</span><br></pre></td></tr></table></figure><p>棒呆！和我们预期的一样，那<code>MyLogger</code>的输出呢？<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irb&gt; MyLogger.new.log(<span class="string">'test!'</span>)</span><br><span class="line">=&gt; <span class="number">2016</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">16</span><span class="symbol">:</span><span class="number">16</span><span class="symbol">:</span><span class="number">32</span> +<span class="number">0200</span>: test!</span><br></pre></td></tr></table></figure></p><p>还是棒呆！那么我刚刚都干了些啥呢？我们创建了一个新的<code>NewCoolLogger</code>类,<code>扩展(extend)</code>了<code>MyLogger</code>类。那些之前依赖老的logger方法的类和方法依然可以正常的工作，老的logger还是和以前一样提供相同的方法，新的logger则提供新的logger方法，这是我们所期待的。<br>我刚才说了两种重构方式，下面我们来看看使用另外一种方式<code>组合</code>来重构代码的例子：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLogger</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(msg, <span class="symbol">formatter:</span> MyLogFormatter.new)</span></span></span><br><span class="line">    STDOUT.write formatter.format(msg)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>我们可以注意到，log方法多了一个可选参数<code>formatter</code>，对于日志格式化的事情本来就应该是<code>MyLogFormatter</code>类的事情，而不应该是logger类的事情。使用上面的方式重构更好，因为这样做了之后<code>MyLogger#log</code>可以接受各种各样不同的格式化方式，而且<code>MyLogger</code>也不在需要去关心具体的格式化格式，因为他只需要一条<code>String</code>，具体是什么格式的则由传入<code>MyLogger#log</code>个格式化类来确定。假如我们又要实现 Error Log 输出，现在简单了只需要传入一个<code>ErrorLogFormatter</code>实例即可输出带有 “[ERROR]” 前缀的日志。</p><h3 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则(LSP)"></a>里氏替换原则(LSP)</h3><p><a href="https://en.wikipedia.org/wiki/Barbara_Liskov" target="_blank" rel="noopener">Barbara Liskov</a>对<code>LSP</code>原则的定义如下：</p><blockquote><p>如果S是T的一个子类，那么不需要修改代码中的任何配置和属性，S的实例也可以替换T的实例对象，而且不影响代码的正常运行。</p></blockquote><p>坦白的讲，我觉得这个定义是非常难理解的，因此经过一番思考，总结下来如下：</p><p>假如现在有一个<code>Bird</code>类，还有两个实例对象 obj1 和 obj2。obj1 是 Duck 类的对象，Duck 类是 Bird 类的子类，obj2 是 Pigeon 类的对象，Pigeon 类也是Bird 类的子类。<code>LSP</code>原则的意思是，obj2 是Bird子类的实例，obj1 是Bird子类的实例，因此我们应当把 obj1 和 obj2 等同对待，都当做Bird的实例对待。</p><blockquote><p>译者注：其实我觉得上面的定义已经说的很清楚了，上面说的 obj1 之类的例子有点多余。。。</p></blockquote><p>下面我们来看个例子来说明下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span></span><br><span class="line">    puts <span class="string">"Hey there!"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &lt; Person</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">years_old</span><span class="params">(age)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I'm <span class="subst">#&#123;age&#125;</span> years old."</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">person = Person.new</span><br><span class="line">student = Student.new</span><br><span class="line"></span><br><span class="line"><span class="comment"># LSP原则的意思是如果我知道 Person 拥有的接口，那么我应该也能猜到 Student 拥有的接口，因为 Student 类是 Person 的子类。</span></span><br><span class="line">student.greet</span><br><span class="line"><span class="comment"># returns "Hey there!"</span></span><br></pre></td></tr></table></figure></p><p>以上就是对<code>LSP</code>原则的解释</p><h3 id="接口分离原则-ISP"><a href="#接口分离原则-ISP" class="headerlink" title="接口分离原则(ISP)"></a>接口分离原则(ISP)</h3><p>接口分离原则的定义如下：</p><blockquote><p>不应该强迫客户端依赖一些他们用不到的方法或接口。</p></blockquote><p>就像定义那样很简单，我们来看看代码说明一下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">turn_on</span></span></span><br><span class="line">    <span class="comment"># turns on the computer</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">type</span></span></span><br><span class="line">  <span class="comment"># type on the keyboard</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">change_hard_drive</span></span></span><br><span class="line">    <span class="comment"># opens the computer body</span></span><br><span class="line">    <span class="comment"># and changes the hard drive</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">use_computer</span></span></span><br><span class="line">    @computer.turn_on</span><br><span class="line">    @computer.type</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Technician</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fix_computer</span></span></span><br><span class="line">    @computer.change_hard_drive</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>在这个例子中有<code>Computer</code>，<code>Programer</code>，<code>Technician</code>三个类。其中<code>Programer</code>，<code>Technician</code>会使用到电脑，而且是以不同的方式使用，<code>Programer</code>使用的是<code>type</code>方法，<code>Technician</code>用的是<code>change_hard_drive</code>，按照<code>LSP</code>原则要求 <strong>不应当强迫客户端依赖一些他们用不到的接口或者方法</strong>，<code>Programer</code>类用不到<code>change_hard_drive</code>方法，同样的<code>Technician</code>用不到<code>type</code>方法，但是一旦这两个方法发生变化，那么就有可能影响到<code>Programer</code>或者<code>Technician</code>类的正常使用。下面我们重构一下代码，来满足<code>LSP</code>原则<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">turn_on</span></span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">type</span></span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputerInternals</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">change_hard_drive</span></span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">use_computer</span></span></span><br><span class="line">    @computer.turn_on</span><br><span class="line">    @computer.type</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Technician</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fix_computer</span></span></span><br><span class="line">    @computer_internals.change_hard_drive</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>经过重构后<code>Technician</code>使用了<code>ComputerInternals</code>类的对象，这个类封装了从<code>Computer</code>中分离出来的方法<code>change_hard_drive</code>。现在<code>Computer</code>类可以受到<code>Programer</code>类的影响(写代码改变OS)，但是再也影响不到<code>Technician</code>类了。</p><h3 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则(DIP)"></a>依赖倒置原则(DIP)</h3><p>依赖倒置原则代表了一种软件模块解耦的方式，他的定义有两部分：</p><blockquote><ol><li>上层模块不应该依赖下层模块，他们应该都依赖抽象。</li><li>抽象不能依赖具体实现，具体实现应该依赖抽象。</li></ol></blockquote><p>我知道这个理解起来有点绕，但是在开始看具体的例子之前，我希望你不要把 <em>依赖倒置</em> 和 <em>依赖注入</em> 弄混淆，后者是一种软件技巧或者说是一种软件设计模式，而前者是面向对象设计原则的一种。<br>好了下面来看看具体的例子：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Report</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @body = <span class="string">"whatever"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print</span></span></span><br><span class="line">    XmlFormatter.new.generate @body</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XmlFormatter</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(body)</span></span></span><br><span class="line">    <span class="comment"># convert the body argument into XML</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p><code>Report</code>类是用来生成 XML 报表的，在他的初始化方法中，我们设置了报表内容(body)，<code>print</code>方法使用<code>XmlFormatter</code>类去将报表内容转换成 XML 格式。</p><p>下面我们来看看<code>Report</code>这个类，从这个类的名字我们能看出来他是个普通的类，会返回某种类型的报表(report)，但是他没告诉我们会返回哪种格式的报表。事实上对于上面这个例子我们能够很轻松的将<code>Report</code>重命名为<code>XmlReport</code>因为我们知道他的实现细节，知道他只实现了导出 XML 报表的功能，但是与其让<code>Report</code>变的更加具体(丢失更多的扩展性)，我们还不如好好想想怎么去将他更好的抽象。</p><p>目前我们的类依赖<code>XmlReport</code>类和他的<code>generate</code>方法，<code>Report</code>依赖的是一个具体的实现而不是抽象，只有当提供格式化方法的类是<code>XmlFormatter</code>的时候，我们的<code>Report</code>类才能正常的工作。假如我们现在想导出 CSV 或者 JSON 格式的报表怎么办？那我们就只能提供更多的具体的方法，比如<code>print_xml</code>，<code>print_csv</code>，<code>print_json</code>等。这意味着<code>Report</code>类和具体实现绑的非常紧，耦合非常高，他依赖格式化类的类型，但却不依赖这些格式化类的抽象。</p><blockquote><p>译者注：Report 类就是只知道有这么多个格式化类，但是却不知道他们之间有什么共同特点，依赖这些具体的类却不依赖他们的共同特点，也就是不依赖抽象。假如现在又有新的格式，Report 还得去了解新的格式类，如果依赖他们共同拥有的一个格式化的接口，那Report就不用去操心你这个格式化的类到底是格式化成啥了，我直接调用这个格式化的方法就行了。</p></blockquote><p>下面我们重构一下代码：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Report</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @body = <span class="string">"whatever"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(formatter)</span></span></span><br><span class="line">    formatter.generate @body</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XmlFormatter</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(body)</span></span></span><br><span class="line">    <span class="comment"># convert the body argument into XML</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>注意<code>print</code>方法，他知道自己需要一个 formatter，但是他关心的是这个 formatter 的接口。更具体地讲，他只关心这个 formatter 能够给他提供的 <code>generate</code>方法，具体是什么样的 formatter 他不在乎，只要能提供<code>generate</code>方法，帮他完成格式化大业就行。这样设计大家有没有觉得更灵活呢？假如我们现在需要 CSV 格式的报表，我们只需要提供下面这个类就行了。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSVFormatter</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(body)</span></span></span><br><span class="line">    <span class="comment"># convert the body argument into CSV</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p><code>Report#print</code>方法将会接收一个<code>CSVFormatter</code>类的实例对象，这个实例对象能够将报表内容转换成 CSV 格式。</p><p>OK，到此为止 <strong>SOLID</strong> 五中面向对象设计原则已经讲完了，希望大家在日常编写代码的过程中能好好应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://eftimov.net/solid-principles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接: SOLID Principles in Ruby&lt;/a&gt;&lt;br&gt;转载请注明出处：&lt;a href=&quot;http://tedyin.github.io/2016/02/27/solid-principles-in-ruby/&quot;&gt;http://tedyin.github.io/2016/02/27/solid-principles-in-ruby/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为一名程序员无论你的水平高低，你都会想写出一手优秀的代码，但是想写优秀的代码并不容易，因此怎样才能提高我们的代码质量呢？下面来看下我们今天的主角 &lt;code&gt;SOLID 原则&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://tedyin.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="面向对象设计" scheme="http://tedyin.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 的批处理</title>
    <link href="http://tedyin.github.io/2016/01/26/elasticsearch-batch-processing/"/>
    <id>http://tedyin.github.io/2016/01/26/elasticsearch-batch-processing/</id>
    <published>2016-01-26T14:00:00.000Z</published>
    <updated>2016-02-29T09:44:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面已经介绍了如何使用ES提供的REST API去做CRUD操作,但是这些操作都是单一的.今天来介绍一下ES中的批处理,可以批量CUD索引和文档<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">curl</span> -XPOST <span class="string">'localhost:9200/bank/account/_bulk?pretty'</span> --data-binary <span class="string">"<span class="variable">@accounts</span>.json"</span></span><br></pre></td></tr></table></figure></p><blockquote><p><code>@accounts.json</code>是存在当前目录下的一个json文件,里面存储了一个josn数组,你可以让她存储任何结构相同的数组.</p></blockquote><p>所有的批量操作都是使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html" target="_blank" rel="noopener">_bluk API</a>来完成,上面的操作就是为<code>accounts.json</code>里面的数据建立索引.<br><a id="more"></a></p><ul><li>除了批量操作数据之外,ES还可以对一条或多条数据进行多步骤操作.<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST <span class="string">'localhost:9200/blog/article/_bulk?pretty'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;"</span>index<span class="string">":&#123;"</span>_id<span class="string">":"</span><span class="number">1</span><span class="string">"&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;"</span>title<span class="string">": "</span>batch bulk api title <span class="number">1</span><span class="string">" &#125;</span></span><br><span class="line"><span class="string">&#123;"</span>update<span class="string">":&#123;"</span>_id<span class="string">":"</span><span class="number">2</span><span class="string">"&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;"</span>doc<span class="string">": &#123;"</span>title<span class="string">": "</span>batch bulk api title <span class="number">2</span><span class="string">" &#125;&#125;</span></span><br><span class="line"><span class="string">&#123;"</span>delete<span class="string">":&#123;"</span>_id<span class="string">":"</span><span class="number">3</span><span class="string">"&#125;&#125;</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure></li></ul><p>上面的批量操作一共干了三件事情:</p><ol><li>将id是1的Document重新以新的数据重新索引,因此该Document的version会自增1</li><li>更新了id是2的Document中的<code>title</code>数据,只是更新数据,并不涉及到重新索引所以version不会变化</li><li>删除了id为3的文档<br>更多的批处理操作可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html" target="_blank" rel="noopener">Bulk API</a></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/_batch_processing.html" target="_blank" rel="noopener">Elasticsearch Batch Processing</a><br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html" target="_blank" rel="noopener">Elasticsearch Bulk API</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面已经介绍了如何使用ES提供的REST API去做CRUD操作,但是这些操作都是单一的.今天来介绍一下ES中的批处理,可以批量CUD索引和文档&lt;br&gt;&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;curl&lt;/span&gt; -XPOST &lt;span class=&quot;string&quot;&gt;&#39;localhost:9200/bank/account/_bulk?pretty&#39;&lt;/span&gt; --data-binary &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;@accounts&lt;/span&gt;.json&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@accounts.json&lt;/code&gt;是存在当前目录下的一个json文件,里面存储了一个josn数组,你可以让她存储任何结构相同的数组.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有的批量操作都是使用&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;_bluk API&lt;/a&gt;来完成,上面的操作就是为&lt;code&gt;accounts.json&lt;/code&gt;里面的数据建立索引.&lt;br&gt;
    
    </summary>
    
    
      <category term="elasticsearch" scheme="http://tedyin.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch CRUD</title>
    <link href="http://tedyin.github.io/2016/01/25/elasticsearch-crud/"/>
    <id>http://tedyin.github.io/2016/01/25/elasticsearch-crud/</id>
    <published>2016-01-25T02:22:00.000Z</published>
    <updated>2016-02-29T09:43:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>有了对ES的基本概念后,下面要做的就是了解如何与ES进行交流,ES非常贴心的提供了一套REST API让大家与他进行交流.这些API能做的事情包括以下几点</p><ul><li>检查你的集群,节点以及索引的状态信息</li><li>管理你的集群,节点以及索引等的数据</li><li>执行高级的搜索操作等<br>总之有了这套REST API你几乎可以让ES干它所能干的所有事.<a id="more"></a><h2 id="状态查询API"><a href="#状态查询API" class="headerlink" title="状态查询API"></a>状态查询API</h2>可以使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html" target="_blank" rel="noopener">_cat API</a>去查询集群节点索引等的状态.</li></ul><h3 id="查询集群健康状态"><a href="#查询集群健康状态" class="headerlink" title="查询集群健康状态"></a>查询集群健康状态</h3><ol><li><code>clur localhost:9200/_cat/health?v</code>查看集群状态,返回结果里有一个<code>status</code>的状态,它有三个值<code>green</code>,<code>yellow</code>,<code>red</code></li></ol><blockquote><ul><li><p><code>green</code>表示一切OK,可以提供搜索服务</p></li><li><p><code>yellow</code>表示所有的索引及其他状态都正常,但是副本数据不完整,有些分片没有副本数据,但是可以提供正常的搜索服务</p></li><li><p><code>red</code> 表示部分数据丢失,能提供部分搜索服务</p></li></ul><p>如果你是在本机上跑一个单节点的集群,那么<code>status</code>会是<code>yellow</code>的是因为,如果是单个节点,ES创建索引时并不会真的去分配副本,因为将副本和分片放在同一个节点里是无意义的,所以此处会返回<code>yellow</code>给出警告,如果当有新的Node加入,并且副本被分配到了新的节点里,这个索引的<code>status</code>就会变成<code>green</code></p></blockquote><ol><li><code>curl localhost:9200/_cat/nodes?v</code>查看节点状态</li><li><code>curl localhost:9200/_cat/indices?v</code>查看索引状态`</li></ol><h2 id="索引和文档CRUD"><a href="#索引和文档CRUD" class="headerlink" title="索引和文档CRUD"></a>索引和文档CRUD</h2><h3 id="目标数据"><a href="#目标数据" class="headerlink" title="目标数据"></a>目标数据</h3><figure class="highlight json"><figcaption><span>lang: json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"1"</span>,</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"New version of Elasticsearch released!"</span>,</span><br><span class="line">      <span class="attr">"content"</span>: <span class="string">"Version 1.0 released today!"</span>,</span><br><span class="line">      <span class="attr">"priority"</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [<span class="string">"announce"</span>, <span class="string">"elasticsearch"</span>, <span class="string">"release"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到JSON文档包含一组字段, <code>&quot;id&quot;: &quot;1&quot;</code>一个字段,<code>&quot;content&quot;: &quot;Version 1.0 released today!&quot;</code>另一个字段,他们都有各自的类型ES会识别出这些类型.</p><h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p>ES为我们提供了一个强大的<code>REST API</code>用来操作ES服务,使用下面的命令来为上面的数据建立索引</p><h4 id="手动指定文档唯一标识符"><a href="#手动指定文档唯一标识符" class="headerlink" title="手动指定文档唯一标识符"></a>手动指定文档唯一标识符</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST <span class="string">http:</span><span class="comment">//localhost:9200/blog/article/1 -d '&#123;</span></span><br><span class="line">      <span class="string">"id"</span>: <span class="string">"1"</span>,</span><br><span class="line">      <span class="string">"title"</span>: <span class="string">"New version of Elasticsearch released!"</span>,</span><br><span class="line">      <span class="string">"content"</span>: <span class="string">"Version 1.0 released today!"</span>,</span><br><span class="line">      <span class="string">"priority"</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="string">"tags"</span>: [<span class="string">"announce"</span>, <span class="string">"elasticsearch"</span>, <span class="string">"release"</span>]</span><br><span class="line">&#125;<span class="string">'</span></span><br></pre></td></tr></table></figure><blockquote><p><code>blog</code> <code>article</code> <code>1</code> 分别是我们建立的<code>索引</code>名称 <code>文档</code>名称 和<code>唯一标识符</code></p></blockquote><p>执行成功后的返回结果:<br><figure class="highlight json"><figcaption><span>lang: json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"_index"</span>:<span class="string">"blog"</span>,</span><br><span class="line"><span class="attr">"_type"</span>:<span class="string">"article"</span>,</span><br><span class="line"><span class="attr">"_id"</span>:<span class="string">"1"</span>,</span><br><span class="line"><span class="attr">"_version"</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">"_shards"</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"total"</span>:<span class="number">2</span>,</span><br><span class="line"><span class="attr">"successful"</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">"failed"</span>:<span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"created"</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>_index: 表示建立索引的名称<code>blog</code>(database name)</li><li>_type: 表示索引的类型 <code>article</code>(table name)</li><li>_Id: 表示文档的唯一标识符 <code>1</code> (可以理解为表的primary key)</li><li>_version: 表示版本信息,该值由ES维护,每次更新索引的时候<code>_version</code>会自动递增</li><li>_shards: 表示其分片信息</li></ul><blockquote><p>如果重复创建Id相同的Document时,只会由ES去更新Document,相应的<code>_version</code>也会递增</p></blockquote><h4 id="自动生成文档的唯一标识符"><a href="#自动生成文档的唯一标识符" class="headerlink" title="自动生成文档的唯一标识符"></a>自动生成文档的唯一标识符</h4><p>只需要将<code>put</code>操作换成<code>post</code>即可,ES会自动为我们的<code>Document</code>生成唯一的标识符.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST <span class="string">http:</span><span class="comment">//localhost:9200/blog/article -d '&#123;</span></span><br><span class="line">      <span class="string">"id"</span>: <span class="string">"1"</span>,</span><br><span class="line">      <span class="string">"title"</span>: <span class="string">"New version of Elasticsearch released!"</span>,</span><br><span class="line">      <span class="string">"content"</span>: <span class="string">"Version 1.0 released today!"</span>,</span><br><span class="line">      <span class="string">"priority"</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="string">"tags"</span>: [<span class="string">"announce"</span>, <span class="string">"elasticsearch"</span>, <span class="string">"release"</span>]</span><br><span class="line">&#125;<span class="string">'</span></span><br></pre></td></tr></table></figure></p><p>返回结果:<br><figure class="highlight json"><figcaption><span>lang: json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"_index"</span>:<span class="string">"blog"</span>,</span><br><span class="line"><span class="attr">"_type"</span>:<span class="string">"article"</span>,</span><br><span class="line"><span class="attr">"_id"</span>:<span class="string">"AVJe9pBhG_DRWvBx76jq"</span>,</span><br><span class="line"><span class="attr">"_version"</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">"_shards"</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"total"</span>:<span class="number">2</span>,</span><br><span class="line"><span class="attr">"successful"</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">"failed"</span>:<span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"created"</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>上面<code>AVJe9pBhG_DRWvBx76jq</code>是由ES自动生成的文档的唯一标识</li></ul><h4 id="创建空的索引"><a href="#创建空的索引" class="headerlink" title="创建空的索引"></a>创建空的索引</h4><p>除了创建包含有文档和类型的索引之外,还可以穿件一个空的索引,里面不包含任何Document和Type<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST <span class="string">localhost:</span><span class="number">9200</span>/empty_index</span><br></pre></td></tr></table></figure></p><p>返回结果:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"acknowledged"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></p><ul><li>一般情况下我们不需要这么做,直接创建正常的索引就行了,如果索引里面没有数据,那么这个索引也是多余的.</li></ul><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>在更新文档的时候,ES并不是直接对已经经过索引的文档进行修改,而是删除旧的文档,并使用新的数据重新索引</p><ul><li><p>只更新<code>title</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST <span class="string">localhost:</span><span class="number">9200</span><span class="regexp">/blog/</span>article<span class="regexp">/1/</span>_update?pretty -d '&#123;</span><br><span class="line">  "doc": &#123; <span class="string">"title"</span>: <span class="string">"New Title"</span> &#125;</span><br><span class="line">&#125;<span class="string">'</span></span><br></pre></td></tr></table></figure></li><li><p>更新<code>title</code>, 并添加<code>author</code>字段.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST <span class="string">localhost:</span><span class="number">9200</span><span class="regexp">/blog/</span>article<span class="regexp">/1/</span>_update?pretty -d '&#123;</span><br><span class="line">  "doc": &#123; <span class="string">"title"</span>: <span class="string">"New Title again !"</span>, <span class="string">"author"</span>: <span class="string">"ES"</span> &#125;</span><br><span class="line">&#125;<span class="string">'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>删除之前创建的index: blog, type: article, id: 1 的文档<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XDELETE <span class="string">localhost:</span><span class="number">9200</span><span class="regexp">/blog/</span>article/<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>返回结果:<br><figure class="highlight json"><figcaption><span>lang: json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"found"</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">"_index"</span>:<span class="string">"blog"</span>,</span><br><span class="line"><span class="attr">"_type"</span>:<span class="string">"article"</span>,</span><br><span class="line"><span class="attr">"_id"</span>:<span class="string">"1"</span>,</span><br><span class="line"><span class="attr">"_version"</span>:<span class="number">3</span>,</span><br><span class="line"><span class="attr">"_shards"</span>:&#123;</span><br><span class="line"><span class="attr">"total"</span>:<span class="number">2</span>,</span><br><span class="line"><span class="attr">"successful"</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">"failed"</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XDELETE <span class="string">localhost:</span><span class="number">9200</span><span class="regexp">/blog/</span>article/<span class="number">1</span></span><br></pre></td></tr></table></figure><p>返回结果:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"acknowledged"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>与创建空索引成功的返回值一样,只返回这个?,是不是意味着ES并没有真正的删除索引内部的数据呢?而是对那些数据进行了标记,然后再以后创建新的索引的时候直接覆盖掉这些数据呢?这个需要进一步研究一下.</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上ES的REST API 都是按照下面的协议来定义的:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X&lt;REST Verb&gt; &lt;Node&gt;<span class="symbol">:&lt;Port&gt;/&lt;Index&gt;/&lt;Type&gt;/&lt;ID&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html" target="_blank" rel="noopener">Elasticsearch Getting Started</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有了对ES的基本概念后,下面要做的就是了解如何与ES进行交流,ES非常贴心的提供了一套REST API让大家与他进行交流.这些API能做的事情包括以下几点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查你的集群,节点以及索引的状态信息&lt;/li&gt;
&lt;li&gt;管理你的集群,节点以及索引等的数据&lt;/li&gt;
&lt;li&gt;执行高级的搜索操作等&lt;br&gt;总之有了这套REST API你几乎可以让ES干它所能干的所有事.
    
    </summary>
    
    
      <category term="elasticsearch" scheme="http://tedyin.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Basic Concepts</title>
    <link href="http://tedyin.github.io/2016/01/24/elasticsearch-basic-concepts/"/>
    <id>http://tedyin.github.io/2016/01/24/elasticsearch-basic-concepts/</id>
    <published>2016-01-24T12:22:00.000Z</published>
    <updated>2016-02-29T09:43:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Cluster-集群"><a href="#Cluster-集群" class="headerlink" title="Cluster 集群"></a>Cluster 集群</h4><p>Cluster 包含了多个运行ES的节点,每个集群都有一个唯一的名字,用来区分不同的集群,含有相同<code>cluster name</code>的<code>Node</code>属于同一个集群<br><a id="more"></a></p><h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><p>运行ES的一个实例</p><h4 id="Index-索引"><a href="#Index-索引" class="headerlink" title="Index 索引"></a>Index 索引</h4><p>相当于MySql 的一个Database,他是Document的集合,每个索引都由他的名称来区分,而且他的名称全是小写的.这个名称可以代表索引,去进行查询更新删除等操作</p><h4 id="Type-类型"><a href="#Type-类型" class="headerlink" title="Type 类型"></a>Type 类型</h4><p>可以理解为Database中的一张表,在一个索引内可以定义多个Type,每一个Type都相当于是对整个索引的一个逻辑分类,就像在一个Database中可以定义多个table,每个table都相当于Database中的一个逻辑分类一样.</p><h4 id="Document-文档"><a href="#Document-文档" class="headerlink" title="Document 文档"></a>Document 文档</h4><p>相当于Table中的一行记录(元组),一个Document是ES中可以被索引的最基本的数据单元,就像Database里每条记录也是一个最基本的单元.每个Document可以包含一个或多个Field.</p><h4 id="Field-字段"><a href="#Field-字段" class="headerlink" title="Field 字段"></a>Field 字段</h4><p>与MySQL中的字段类似,但是ES中的字段是带有值的</p><h4 id="Shards-amp-Replicas-分片-amp-副本"><a href="#Shards-amp-Replicas-分片-amp-副本" class="headerlink" title="Shards &amp; Replicas  分片&amp;副本:"></a>Shards &amp; Replicas  分片&amp;副本:</h4><p>当一个Node上的索引大到该Node的磁盘无法存储这个索引或者索引太大导致搜索效率低下的时候,就可以将这个庞大的索引分成多个分片(Shards),存储在多个Node上,这样就解决了无法存储和搜索低效的问题,因此分片存在有两个中要的原因:</p><ul><li>可以对庞大的索引进行水平切分,这个操作类似于对大表的水平切分</li><li>因为切分成了多个分片,因此就可以并行去进行查询,这样就可以提高查询效率.<br>对于Shards怎样去分发到多个Node,以及搜索完成后讲数据汇总到发起请求的节点,这些工作都是由ES来自动完成的,不需要我们去关心.</li></ul><p>因为服务器存在一定的宕机风险,因此如果所有的Shard都放在某个Node上,如果宕机了,索引就会丢失,因此为了解决这个问题需要对Shards进行备份生产Replica Shards 也叫做Replicas, Replica的主要作用有两个:</p><ul><li>解决Node宕机后,索引丢失的问题</li><li>提高搜索效率,因为Replicas不会放下一个Node下,所以处理搜索请求的时候多个节点可以并行对Replicas进行查询,提高吞吐量.<br>总得来说,每个Index可以被切分成多个分片,每个分片可以有0个或多个副本,在创建索引的时候可以指定分片数和副本数,在成功创建索引后,依然可以通过ES提供的<code>_cat</code>API来修改副本数,但是不能去修改分片数.</li></ul><blockquote><p>一个ES的Shard就是一个Lucene的索引,每个Lucene索引可以存储Integer.MAX_VALUE-128 = 2,147,483,519个Document. 默认情况下一个ES索引有5个分片,每个分片有1个副本,也就是说当你创建一个索引时会产生5个分片,每个分片会有1个副本,总共就相当于1个索引有10个分片.</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/_basic_concepts.html" target="_blank" rel="noopener">Elasticsearch Basic Concepts</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;h4 id=&quot;Cluster-集群&quot;&gt;&lt;a href=&quot;#Cluster-集群&quot; class=&quot;headerlink&quot; title=&quot;Cluster 集群&quot;&gt;&lt;/a&gt;Cluster 集群&lt;/h4&gt;&lt;p&gt;Cluster 包含了多个运行ES的节点,每个集群都有一个唯一的名字,用来区分不同的集群,含有相同&lt;code&gt;cluster name&lt;/code&gt;的&lt;code&gt;Node&lt;/code&gt;属于同一个集群&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android开发中遇到的小问题汇总</title>
    <link href="http://tedyin.github.io/2015/05/03/android-issue/"/>
    <id>http://tedyin.github.io/2015/05/03/android-issue/</id>
    <published>2015-05-03T14:53:00.000Z</published>
    <updated>2016-02-29T09:29:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>在实际的项目开发过程中，经常会遇到一些莫名其妙的问题，或者很容易忽略的但是会造成很多麻烦的小问题，这篇帖子用来记录下这些问题，并给出注意事项或者解决方法，后续会不断更新所遇到的问题和解决方法。</p><ol><li>Fragment中使用onActivityResult方法无效不能有效的回调<a id="more"></a><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3>在Fragment中不要使用getActivity().startActivityForResult()方法去启动Activity，而应该直接使用startActivity方法去启动Activity，否则会被挂载Fragment的Activity中的onActivityResult的方法截获，导致Fragment的onActivityResult方法无法被回调。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://stackoverflow.com/questions/6147884/onactivityresult-not-being-called-in-fragment" target="_blank" rel="noopener">参考Stackoverflow</a></p><ol><li>ViewPager.setCurrentItem(0)后onPageSelect方法没有被触发</li></ol><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>调用完setCurrentItem(0)后再手动调用加载函数。原因是ViewPager内部的mCurrentItem默认值为0，设置了setCurrentItem（0）之后dispatchSelect为false认为已经调用过了onPageSelect方法，因此在第一次调用完setCurrentItem(0)时无效。</p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="http://stackoverflow.com/questions/11794269/onpageselected-isnt-triggered-when-calling-setcurrentitem0" target="_blank" rel="noopener">参考Stackoverflow</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际的项目开发过程中，经常会遇到一些莫名其妙的问题，或者很容易忽略的但是会造成很多麻烦的小问题，这篇帖子用来记录下这些问题，并给出注意事项或者解决方法，后续会不断更新所遇到的问题和解决方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Fragment中使用onActivityResult方法无效不能有效的回调
    
    </summary>
    
    
      <category term="android" scheme="http://tedyin.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>How To Use Jenv To Master Your Java Environnement</title>
    <link href="http://tedyin.github.io/2015/04/26/how-to-use-jenv/"/>
    <id>http://tedyin.github.io/2015/04/26/how-to-use-jenv/</id>
    <published>2015-04-26T12:22:00.000Z</published>
    <updated>2016-02-29T09:37:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于一个Java开发者来说，系统上安装多个Java版本是很常见的事，但是在各个版本之间进行切换是一件非常痛苦的事情，今天向大家介绍一个工具<code>Jenv</code>，用它来终结我们的Java版本管理之痛。</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Jenv的作用类似于rbenv，只是rbenv是用来管理系统上的不同Ruby版本的。Jenv运行在Linux或者Mac上，不能在Windows上使用（建议Win的用户转向Linux或者Mac）。<br><a id="more"></a></p><blockquote><p>本文以Mac系统位例进行介绍。</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>将代码下载到<code>~/.jenv</code>目录下</p><figure class="highlight crmsh"><figcaption><span>lang: bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">https</span>://github.com/gcuisinier/jenv.git ~/.jenv</span><br></pre></td></tr></table></figure></li><li><p>将<code>~/.jenv/bin</code>加入到<code>$PATH</code>环境变量中</p></li><li><p>添加初始化Jenv的脚本到环境变量中</p><figure class="highlight shell"><figcaption><span>lang: bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'eval "$(jenv init -)"'</span> &gt;&gt; ~/.bash_profile</span></span><br></pre></td></tr></table></figure></li><li><p>重启命令行，使PATH的设置生效，现在可已使用jenv来管理JDK版本了。</p></li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>下面介绍几个最常用的Jenv命令</p><blockquote><ol><li><p><code>jenv version</code> 显示当前正在使用的JDK版本号</p></li><li><p><code>jenv versions</code> 显示当前系统上已将安装的所有JDK版本号</p></li><li><p><code>jenv local [java version]</code> 指定当前目录下要使用的JDK版本号，只在该目录及其子目录内有效，在该目录以外还是使用原有的JDK版本。</p></li><li><p><code>jenv global [java version]</code> 指定全局的JDK版本号，在整个系统中有效。</p></li><li><p><code>jenv info java</code> 检查<code>JAVA_HOME</code>设置是否有效，如果有效会输出<code>JAVA_HOME</code>的路径</p></li><li><p><code>jenv local --unset</code> 消除jenv local的设置，恢复使用默认的JDK版本</p></li></ol></blockquote><h1 id="该项目Github地址"><a href="#该项目Github地址" class="headerlink" title="该项目Github地址"></a>该项目Github地址</h1><p><a href="https://github.com/gcuisinier/jenv" target="_blank" rel="noopener">Jenv</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对于一个Java开发者来说，系统上安装多个Java版本是很常见的事，但是在各个版本之间进行切换是一件非常痛苦的事情，今天向大家介绍一个工具&lt;code&gt;Jenv&lt;/code&gt;，用它来终结我们的Java版本管理之痛。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Jenv的作用类似于rbenv，只是rbenv是用来管理系统上的不同Ruby版本的。Jenv运行在Linux或者Mac上，不能在Windows上使用（建议Win的用户转向Linux或者Mac）。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Parcelable Vs Serializable</title>
    <link href="http://tedyin.github.io/2015/04/03/parcelable-vs-serializable/"/>
    <id>http://tedyin.github.io/2015/04/03/parcelable-vs-serializable/</id>
    <published>2015-04-03T14:28:00.000Z</published>
    <updated>2016-02-29T09:29:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天说一下对象序列化时的两个接口<code>Serializable</code>和<code>Parcelable</code>，前者是Java中的老面孔了，大家也都非常熟悉了，后者是Android提供的新面孔，既然Java本身就有序列化的接口为什么Android还要重新造轮子呢？当然Google也不是傻子，肯定是前面那个轮子不能满足他们的要求，所以他们才重新造出了<code>Parcelable</code>这个接口。<br><a id="more"></a></p><h2 id="Serializable接口的使用"><a href="#Serializable接口的使用" class="headerlink" title="Serializable接口的使用"></a>Serializable接口的使用</h2><p>首先来看看<code>Serializable</code>如何使用。<br><figure class="highlight zephir"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableClass</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">float</span> height;</span><br><span class="line"><span class="keyword">List</span>&lt;Skill&gt; skillList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Skill</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">String skillName;</span><br><span class="line"><span class="keyword">boolean</span> gotIt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了，这样就可以直接将这个类序列化后使用Intent/Bundle进行传递了。使用起来非常简单，只需要实现<code>Serializable</code>接口即可。<code>Serializable</code>接口是一个标志接口，只要实现了这个接口，你就不需要做任何操作，Java会使用Reflection(反射技术)将类进行序列化和反序列化，非常的简单方便。但是有一个问题就是<strong>效率太低</strong>,在序列化和反序列化过程中会创建许多中间对象，会使得GC多次被调用，从而影响到程序的性能，我们都知道在GC被触发后进行垃圾回收的过程中，线程是被挂起的，APP会处于无响应状态，尽管这个过程持续的时间很短很短只有几十毫秒，但如果多次重复必定会影响到用户体验，一次Google的大牛们就不淡定了，这么差的性能怎么忍得了？但是如何破呢？答案就是<code>Parcelable</code>，他们造出了<code>Parcelable</code>来解决这个问题。</p><p>##Parcelable接口的使用<br>和上面一样，还是先来看看<code>Parcelable</code>接口是如何使用的。<br><figure class="highlight groovy"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelableClass</span> <span class="keyword">implements</span> <span class="title">Parcelable</span>&#123;</span></span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">float</span> height;</span><br><span class="line">List&lt;Skill&gt; skillList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;ParcelableClass&gt; CREATOR</span><br><span class="line">= <span class="keyword">new</span> Parcelable.Creator&lt;ParcelableClass&gt;()&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Overried</span></span><br><span class="line">ParcelableClass createFromParcel(Parcel <span class="keyword">in</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ParcelableClass(<span class="keyword">in</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Overried</span></span><br><span class="line">ParcelableClass[] newArray(<span class="keyword">int</span> size)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ParcelableClass[size];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ParcelableClass(Parcel <span class="keyword">in</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="keyword">in</span>.readString();</span><br><span class="line"><span class="keyword">this</span>.age = <span class="keyword">in</span>.readInt();</span><br><span class="line"><span class="keyword">this</span>.height = <span class="keyword">in</span>.readFloat();</span><br><span class="line"><span class="keyword">this</span>.skillList = <span class="keyword">new</span> ArrayList&lt;Skill&gt;();</span><br><span class="line"><span class="keyword">in</span>.readTypedList(skillList,Skill.CREATOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Overried</span></span><br><span class="line"><span class="keyword">void</span> writeToParcel(Parcel dest, <span class="keyword">int</span> flags)&#123;</span><br><span class="line">dest.writeString(<span class="keyword">this</span>.name);</span><br><span class="line">dest.writeInt(<span class="keyword">this</span>.age);</span><br><span class="line">dest.writeFloat(<span class="keyword">this</span>.height);</span><br><span class="line">dest.writeTypedList(<span class="keyword">this</span>.skillList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Overried</span></span><br><span class="line"><span class="keyword">int</span> describeContents()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Skill</span> <span class="keyword">implements</span> <span class="title">Parcelable</span>&#123;</span></span><br><span class="line">String skillName;</span><br><span class="line"><span class="keyword">boolean</span> gotIt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Skill&gt; CREATOR</span><br><span class="line">= <span class="keyword">new</span> Parcelable.Creator&lt;Skill&gt;()&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Overried</span></span><br><span class="line">Skill createFromParcel(Parcel <span class="keyword">in</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Skill(<span class="keyword">in</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Overried</span></span><br><span class="line">Skill[] newArray(<span class="keyword">int</span> size)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Skill[size];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Skill(Parcel <span class="keyword">in</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>.skillName = <span class="keyword">in</span>.readString();</span><br><span class="line"><span class="keyword">this</span>.gotIt = <span class="keyword">in</span>.readBoolean();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Overried</span></span><br><span class="line"><span class="keyword">int</span> describeContents()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Overried</span></span><br><span class="line"><span class="keyword">void</span> writeToParcel(Parcel dest, <span class="keyword">int</span> flags)&#123;</span><br><span class="line">dest.writeString(skillName);</span><br><span class="line">dest.writeBoolean(gotIt ? 1 : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Skill</span> <span class="keyword">implements</span> <span class="title">Parcelable</span>&#123;</span></span><br><span class="line">String skillName;</span><br><span class="line"><span class="keyword">boolean</span> gotIt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>终于写完了，这比刚才使用<code>Serializable</code>接口时的代码长了好几倍，代码的可读性也大不如刚刚的代码，但是为了性能上的提升，这么做也是值得的，与性能相比代码多点难点又算得了什么呢？何况这个代码也不是很难，而且是有迹可循的:</p><blockquote><ol><li>每个实现了Parcelable的接口都需要实现一个<code>Parcelable.Creator</code>对象。</li><li>提供一个以Parcel为参数的构造函数。</li><li>实现<code>describeContents()</code>方法</li><li>实现<code>writeToParcel(Parcel dest, int flags)</code>方法。</li></ol></blockquote><p>这样就OK了,下面来看看废了一番周折写出来的序列化方法到底比原生的好了多少，有图有真相！！<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/parcelable_vs_serializable.png" alt="parcelable"></p><p>OMG !这差距，使用<code>Parcelable</code>虽然复杂点，但是这性能提升，真是值了！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.developerphil.com/parcelable-vs-serializable/" target="_blank" rel="noopener">Parcelable vs Serializable</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天说一下对象序列化时的两个接口&lt;code&gt;Serializable&lt;/code&gt;和&lt;code&gt;Parcelable&lt;/code&gt;，前者是Java中的老面孔了，大家也都非常熟悉了，后者是Android提供的新面孔，既然Java本身就有序列化的接口为什么Android还要重新造轮子呢？当然Google也不是傻子，肯定是前面那个轮子不能满足他们的要求，所以他们才重新造出了&lt;code&gt;Parcelable&lt;/code&gt;这个接口。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Tools Attribute</title>
    <link href="http://tedyin.github.io/2015/03/28/tools-usage/"/>
    <id>http://tedyin.github.io/2015/03/28/tools-usage/</id>
    <published>2015-03-28T14:29:00.000Z</published>
    <updated>2016-02-29T09:29:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android tools提供了一组非常有用的属性方法来方便我们开发，tools所指定的所有属性在打包的时候都不会打包到APK里，它只是辅助开发的一组工具属性，本文基于Android Studio，快捷建使用Mac OSX 10.5+ KeyMap，下面以IDE来表示Android Studio。<br><a id="more"></a></p><p>##tools : context<br>使用context属性来告诉IDE，这个布局文件是哪个Activity的布局文件，所以在预览的时候需要根据这个Activity的主题属性来显示，而不是使用默认的主题来进行预览。除了这个作用之外还有另外一点，在IDE中使用Go to Related files（快捷键CMD+Ctrl+Up）功能来帮助找到相关的布局文件。context属性在填写的时候，需要填上Activity的完整包名。<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/tools_1.png" alt="p1"></p><p>##tools:menu<br>如果你已经使用了context属性指定过了对应的Activity，那么IDE默认会自己去检查OnCreateOptionsMenu里面使用了哪个menu布局，然后在预览的时候加载该布局。使用menu属性可以覆盖上述默认操作。如果不想显示menu则可以设置tools:menu=“”即可。另外还可以使用menu属性定义多个菜单资源，如果不想显示menu则可以给menu属性赋值为空，例如：tools:menu=“”即可。另外，还可以在预览的时预览任意个你想看到的menu菜单项，而不是直接预览menu布局里面的内容。实现这样的效果十分简单，只需要在menu后面写上对应的菜单项的Id并用“ , ”隔开即可。举个例子：<br><code>tools:menu=“action_search,action_add&quot;</code><br>还有一点需要注意的就是，在使用Theme.AppCompat时，menu这个属性不起作用。</p><p>##tools:actionBarNavMod<br>使用该属性告诉IDE我要显示的ActionBar的模式，包含了三个选项standard、tabs、list，该属性只有在Holo主题下有用，在其他主题下无法使用。</p><p>##tools:listitem，tools:listheader，tools:listfooter<br>从名字就可以看出他们的意思，这是一组属性，我们可以使用这些属性分别告诉IDE一下信息:</p><ol><li>listitem是告诉IDE这个列表里面的Item内容是什么，在预览的时候可以和Item一起预览，而不是傻傻的默认显示一行文字。</li><li>listheader是告诉IDE这个列表的头部是什么，并一起预览</li><li>listfooter是告诉IDE这个列表的底部是什么，并一起预览需要注意的一点是，listheader和listfooter对GridView是没有效果的。</li></ol><p>##tools:layout<br>用这个属性告诉IDE，这个Layout在预览的时候应该显示什么东西，而不是显示一片空白。<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/tools_2.png" alt="p2"></p><p>##补充：</p><ol><li>tools:text属性用来显示要预览的文字，预览时会覆盖text属性的内容。</li><li>tools:src属性用来显示要预览的图片资源。</li></ol><p>#tools 中对Lint处理的属性</p><p>##tools:ignore<br>该属性对那些有“强迫症”的患者非常有用，经常我们在布局文件中写完ImageView后，都会提示少了Description，每次看见那个小黄线的提示就会觉得非常别扭，但是有了这个属性，就不用担心了，只要在ImageView的属性设置后面加上tools:ignore=“contentDescription”即可立马解决问题。除了上述用法外，还可以用在别的想忽略警告的地方。</p><p>##tools:targetApi<br>这个属性从名字就可以看出是用来指定API的。如果我们的minSdk是11，但是我们用了一个在API 14后才有的控件，在布局编辑器里就会报错，那么在报错的控件下面使用targetApi并指定对应的API即可解决问题。<br><figure class="highlight groovy"><figcaption><span>lang: xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ripple <span class="string">xmlns:</span>android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line"><span class="string">android:</span>color=<span class="string">"@color/accent_color"</span></span><br><span class="line"><span class="string">tools:</span>targetApi=<span class="string">"LOLLIPOP"</span> /&gt;</span><br></pre></td></tr></table></figure><br>好了，tools的用法基本就介绍完了，详细的列表可以<a href="http://tools.android.com/tech-docs/tools-attributes" target="_blank" rel="noopener">参考这里</a></p><p>##参考<br><a href="https://medium.com/sebs-top-tips/tools-of-the-trade-part-2-b91271892d10" target="_blank" rel="noopener">英文</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0309/2567.html" target="_blank" rel="noopener">中文版</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android tools提供了一组非常有用的属性方法来方便我们开发，tools所指定的所有属性在打包的时候都不会打包到APK里，它只是辅助开发的一组工具属性，本文基于Android Studio，快捷建使用Mac OSX 10.5+ KeyMap，下面以IDE来表示Android Studio。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android View Lifecycle</title>
    <link href="http://tedyin.github.io/2015/03/11/android-view-lifecycle/"/>
    <id>http://tedyin.github.io/2015/03/11/android-view-lifecycle/</id>
    <published>2015-03-11T13:00:00.000Z</published>
    <updated>2016-02-29T09:29:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Android开发中了解各个组件的生命周期非常重要，网上已经有许多关于Activity、Fragment等的生命周期的介绍了，今天来介绍一下View的生命周期。<br><a id="more"></a></p><p>##什么是View<br>先来看看官方文档的解释：</p><blockquote><p>This class represents the basic building block for user interface components. A View occupies a rectangular area on the screen and is responsible for drawing and event handling. View is the base class for widgets, which are used to create interactive UI components (buttons, text fields, etc.). The ViewGroup subclass is the base class for layouts, which are invisible containers that hold other Views (or other ViewGroups) and define their layout properties.</p></blockquote><p>也就是说View是最基础的UI组件，所有的其他的UI组件都是从View类中衍生出来的，可见View的地位是多么的高，所以需要掌握View的各个细节。</p><p>##View生命周期中用到的方法</p><p>###1. View的创建期：<br>使用View的构造函数进行创建，在这个过程中，如果有自定义的属性的话，也需要在这个期间进行处理。当View和他的子View全部从XML中inflate结束后，会调用<code>View#onFinishInflate()</code>方法。</p><p>###2. View的布局过程<br>整个布局过程做的就是处理View的大小和位置相关的信息。<br><code>View#onMesure()</code>方法的作用就是计算每个控件在屏幕上的尺寸大小。<code>View#onLayout</code>方法的作用就是设置所有控件的大小和位置。<br><code>View#onSizeChanged</code>方法的作用是当View的大小改变会调用此方法。</p><p>###3. View的渲染<br>View的渲染过程会调用onDraw方法。</p><p>###4. View对事件的处理<br>处理View事件方法有<code>View#onKeyDown()</code>当设备的物理按键按下后会触发该方法；<code>View#onKeyUp()</code>当设备的物理按键弹起的时候就会触发该方法；<code>View#onTrackballEvent()</code>当轨迹球被触动的时候会触发该方法；<br><code>View#onTouchEvent()</code>当设备的屏幕有来自用户的触摸操作时会回调该法，比如某些滑动操作我们就可以在该方法中拦截处理，可以根据用户的不同滑动距离和滑动速度等用户操作，给出许多不同的反馈，提供更好的用户体验。</p><p>###5. View对焦点的处理<br>处理焦点相关事件的回调方法为<code>View#onFocusChanged()</code>当控件的焦点发生改变，会触发该方法。</p><p>###6. View在根节点上的挂载和删除<br>当View通过构造函数创建出来后，如果不挂载到Window上时，是无法显示出来的。当View要挂载到Window上时会调用<code>Veiw#onAttachedToWindow()</code>方法；当View被销毁后要从Window上去除时会调用<code>View#onDetachedFromWindow()</code>方法；当Window隐藏或者可见时会调用<code>View#onWindowVisibilityChanged()</code>方法。通过这几个方法我们可以处理一些初始化的操作，和一些在View被销毁后进行的内存回收或者善后的工作。</p><p>##View的生命周期示意图<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/view_lifecycle.png" alt="view_lifecycle"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android开发中了解各个组件的生命周期非常重要，网上已经有许多关于Activity、Fragment等的生命周期的介绍了，今天来介绍一下View的生命周期。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android UI Tips</title>
    <link href="http://tedyin.github.io/2015/01/18/android-ui-tips/"/>
    <id>http://tedyin.github.io/2015/01/18/android-ui-tips/</id>
    <published>2015-01-18T15:30:00.000Z</published>
    <updated>2016-02-29T09:29:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h3><ol><li>使用SparseArray代替HashMap等容器类。</li><li>能复用时一定要复用，不能复用时尽量复用。复用一切！</li><li>使用静态工厂方法去获取对象（使用Message时不要自己去new Message，要使用Message.obtain()方法去获取）这样可以减少不必要的对象，复用已有的对象。</li><li>使用一个全局变量代替多个临时变量。</li><li>使用Handler、AsyncTask、Loader、IntentService处理异步任务，而非仅使用java.concurrent包</li><li>给你的线程一个优先级，如果是处理后台任务的线程，设置他的优先级为Background。</li><li><p>对于ListView的3种状态进行处理，从而优化代码，提升性能。(例如在滑动过程中停止图片的加载，等恢复正常后再继续加载图)</p><a id="more"></a><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3></li><li><p>不要阻塞Main Thread（UI Thread）</p></li><li>扁平化你的布局层次（能用一个Layout最好，可以使用merge代替FrameLayout）</li><li>能复用就尽量复用一切可复用的东西。</li><li>延迟加载一些不需要立即使用的内容。</li><li>对你的Thread或者Task设置优先级，UI任务和Thread永远是最高级。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><p><a href="https://speakerdeck.com/cyrilmottier/optimizing-android-ui-pro-tips-for-creating-smooth-and-responsive-apps" target="_blank" rel="noopener">Android UI Tips</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips:&quot;&gt;&lt;/a&gt;Tips:&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;使用SparseArray代替HashMap等容器类。&lt;/li&gt;
&lt;li&gt;能复用时一定要复用，不能复用时尽量复用。复用一切！&lt;/li&gt;
&lt;li&gt;使用静态工厂方法去获取对象（使用Message时不要自己去new Message，要使用Message.obtain()方法去获取）这样可以减少不必要的对象，复用已有的对象。&lt;/li&gt;
&lt;li&gt;使用一个全局变量代替多个临时变量。&lt;/li&gt;
&lt;li&gt;使用Handler、AsyncTask、Loader、IntentService处理异步任务，而非仅使用java.concurrent包&lt;/li&gt;
&lt;li&gt;给你的线程一个优先级，如果是处理后台任务的线程，设置他的优先级为Background。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于ListView的3种状态进行处理，从而优化代码，提升性能。(例如在滑动过程中停止图片的加载，等恢复正常后再继续加载图)&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用反射自定义SearchView</title>
    <link href="http://tedyin.github.io/2015/01/02/use-reflect-modify/"/>
    <id>http://tedyin.github.io/2015/01/02/use-reflect-modify/</id>
    <published>2015-01-02T02:00:00.000Z</published>
    <updated>2016-02-29T09:29:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在优化代码，发现Android support v7包中的SearchView，开放的方法很少，导致SearchView自定义比较麻烦。所以在网上搜索解决办法，发现借助Java强大的反射功能来动态修改SearchView是最合适的方法。<br><a id="more"></a><br>下面来举个例子来说明一下如何使用反射来实现自定义SearchView的效果：</p><p>比如SearchView中展开后的底部Hint背景有一个搜索的图标，但是我们要是想隐藏该图标是没有办法直接隐藏的，因此我们可以使用反射来进行动态修改，为了可以使用反射，因此我们要查看SearchView的源码然后找出该图标的所属控件，然后使用反射动态修改该控件的属性，从而达到隐藏该图标的目的。<br>下面来看下具体步骤：</p><p>###查看源码<br>经过查看SearchView的源码，我们发现这个图标是SearchView中的 SearchAutoComplete的Hint属性，源码如下：<br><figure class="highlight axapta"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mQueryHint != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mQueryTextView.setHint(getDecoratedHint(mQueryHint));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSearchable != <span class="keyword">null</span>) &#123;</span><br><span class="line">    CharSequence <span class="keyword">hint</span> = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> hintId = mSearchable.getHintId();</span><br><span class="line">    <span class="keyword">if</span> (hintId != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">hint</span> = getContext().getString(hintId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">hint</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mQueryTextView.setHint(getDecoratedHint(<span class="keyword">hint</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mQueryTextView.setHint(getDecoratedHint(<span class="string">""</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###使用反射修改SearchView<br>从上述代码可以看出，显示Hint的是<code>mQueryHint</code>,因此只要将这个Hint值设为“”空字符串就可以隐藏该icon。下面使用反射的方式获取mQueryTextView这个private级别的控件,并将Hint设为空字符串，代码如下：</p><figure class="highlight aspectj"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">hideCloseSearchIcon</span><span class="params">(SearchView searchView)</span> </span>&#123;</span><br><span class="line">SearchAutoComplete mQueryTextView = (SearchAutoComplete) SystemUiHelper.getFieldByReflect(</span><br><span class="line"><span class="string">"mQueryTextView"</span>, SearchView.class, searchView);</span><br><span class="line">mQueryTextView.setHint(R.string.hint_search);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Object <span class="title">getFieldByReflect</span><span class="params">(String fieldName, Class&lt;?&gt; claz, Object <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Field searchField = claz.getDeclaredField(fieldName);</span><br><span class="line">searchField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="function"><span class="keyword">return</span> searchField.<span class="title">get</span><span class="params">(<span class="keyword">target</span>)</span></span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以将SearchView中输入框旁边的icon去掉了，下面看下对比图：</p><p>去掉之前的样子：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/search1.png" alt="search1"><br>去掉之后的样子：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/search2.png" alt="search2"></p><p>同理，可以使用反射做很多类似的修改和操作,只有你想不到的没有你做不到的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在优化代码，发现Android support v7包中的SearchView，开放的方法很少，导致SearchView自定义比较麻烦。所以在网上搜索解决办法，发现借助Java强大的反射功能来动态修改SearchView是最合适的方法。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android HttpURLConnection VS HttpClient</title>
    <link href="http://tedyin.github.io/2014/12/22/httpclient-urlconnection/"/>
    <id>http://tedyin.github.io/2014/12/22/httpclient-urlconnection/</id>
    <published>2014-12-22T15:40:00.000Z</published>
    <updated>2016-02-29T09:30:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Android中提供了两种Http操作的封装，一种使用HttpURLConnection去进行网络操作，另外一种是使用HttpClient进行网络操作的处理，这两者在Android中共存，但是官方建议使用HttpURLConnection来进行网络处理。<br><a id="more"></a></p><p>##HttpClient与HttpURLConnection在Android中的比较</p><p>Android中直接封装了Apache的HttpClient来作为网络操的处理类，该类是非常强大的类，比较重量级，功能和方法非常丰富，因此带来了一个问题，那就是定制性非常差，修改起来非常麻烦。相比而言HttpURLConnection要轻量许多，方法较少而且都比较简单，因此定制性更强，修改起来容易，Android团队内部也更倾向使用定制性更好的HttpURLConnection来进行网络处理。</p><p>但是因为在FROYO版本以及之前版本，Android对HttpURLConnection支持不好，HttpURLConnection有许多bug，所以在2.3版本之前建议使用HttpClient来进行网络操作。在FROYO以及之后的版本Android修复了HttpURLConnection的许多问题，而且在4.0之后HttpURLConnection还加入了对缓存的支持，使用下面方法可以在4.0版本中开启Http缓存:</p><figure class="highlight gradle"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> enableHttpResponseCache()&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">long</span> httpCacheSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 10 MiB</span></span><br><span class="line">    <span class="keyword">File</span> httpCacheDir = <span class="keyword">new</span> <span class="keyword">File</span>(getCacheDir(), <span class="string">"http"</span>);</span><br><span class="line">    <span class="keyword">Class</span>.forName(<span class="string">"android.net.http.HttpResponseCache"</span>)</span><br><span class="line">        .getMethod(<span class="string">"install"</span>, <span class="keyword">File</span>.<span class="keyword">class</span>, <span class="keyword">long</span>.<span class="keyword">class</span>)</span><br><span class="line">        .invoke(<span class="keyword">null</span>, httpCacheDir, httpCacheSize);</span><br><span class="line">&#125;cache(Exception httpResponseCacheNotAvailable)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端配置好缓存处理后，同样需要在服务端进行配置支持HttpCache，否则Cache是不会生效的。<br>在2.3以及以后的版本中，HttpURLConnection默认是支持<code>Accept-Type:gzip</code>的，只需要在服务端配置一下即可，在消息传输和获取的过程中使用压缩数据进行传输，这样会更加快速的传递数据，而且省电省流量。但是如果服务端支持gzip格式数据传输，那么在使用<code>getContentLength()</code>方法获取的就是压缩后的数据大小，这一定要注意。</p><p>##到底使用哪一个？<br>上面已经说的很明确了，在2.3版本之前使用HttpClient进行网络请求，在FROYO版本之后使用HttpURLConnection进行网络请求，因为2.3以前的版本市场份额已经很小很小了，所以在以后的开发中可以略去选择直接使用HttpURLConnection进行网络操作，而且Android官方也会持续改进HttpURLConnection在Android中的性能。</p><p>##参考<br>(参考)[<a href="http://android-developers.blogspot.tw/2011/09/androids-http-clients.html" target="_blank" rel="noopener">http://android-developers.blogspot.tw/2011/09/androids-http-clients.html</a>]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android中提供了两种Http操作的封装，一种使用HttpURLConnection去进行网络操作，另外一种是使用HttpClient进行网络操作的处理，这两者在Android中共存，但是官方建议使用HttpURLConnection来进行网络处理。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ViewPager PageTransformer 应用</title>
    <link href="http://tedyin.github.io/2014/12/21/pager-transformer/"/>
    <id>http://tedyin.github.io/2014/12/21/pager-transformer/</id>
    <published>2014-12-21T13:07:00.000Z</published>
    <updated>2016-02-29T09:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中要有个需求就是做出一个可以滑动的列表，类似于Paper效果的动画，期初设想的比较复杂，自定义监控ViewPager的OnScroll事件，然后再在onPageScrolled中根据<code>position</code>, <code>positionOffset</code>, <code>positionOffsetPixels</code>等数据就算出滑动的百分比，通过滑动的百分比来控制动画播放的百分比。这样虽然也可以实现想要的效果，但是会很复杂，有许多中间状态需要我们自己计算和保存，维护起来非常麻烦。<br><a id="more"></a><br>在这些复杂的实现后，在朋友的建议下使用了<code>ViewPager.PageTransformer</code>来重新实现上述效果，瞬间简单了许多，很多中间状态不许需要自己去维护，PagerTransformer会帮你去维护，并且在他提供的方法中<code>transformPage(View page, float position)</code>已经帮你计算好了滑动百分比，根本不需要你再去计算，这个简直太贴心了。其实在滑动过程中对UI修改最重要的也是最麻烦的就是去计算滑动的百分比，现在有了这个百分比，你想实现什么动画就实现什么动画，简直太爽了。</p><p>在使用ViewPager.PageTransformer的时候需要注意的就是他的接口方法中的postion，只要理解了它的用法，PageTransformer才算是用熟了。首先来介绍下position的用法：</p><ul><li><p>position 是一个float值，它代表了一个页面离开屏幕的百分比，以及另一个页面进入的百分比</p></li><li><p>position = 0  : page完全被展示，也就是说page处于屏幕的正中间</p></li><li>position = 1  : page完全处于屏幕的右边</li><li>position = -1 : page完全处于屏幕的左边</li></ul><p>如果用户拖拽position=0(当前屏幕正中央的page)的page从右往左滑动，当只滑动一半的时候，原来position = 0的page其position会由0逐渐变为 -0.5，position=1的page（屏幕右侧的page）其position会由1逐渐变为 0.5。</p><blockquote><p>注意：<br>从右往左滑 &lt;——  position为负数<br>从左往右滑 ——&gt;  position为正数</p></blockquote><p>好了理解了上面所讲的内容就可以真正的去做出漂亮的动画了，下面给一个动画实例<br><figure class="highlight java"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RotatePageTransformer</span> <span class="keyword">implements</span> <span class="title">ViewPager</span>.<span class="title">PageTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> MIN_TRAN = <span class="number">50f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_ROTATE = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transformPage</span><span class="params">(View view, <span class="keyword">float</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> rotateFactor = MIN_ROTATE * position;</span><br><span class="line">            <span class="keyword">float</span> tranFactor = MIN_TRAN * position;</span><br><span class="line">            <span class="keyword">if</span> (position &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                view.setTranslationY(-tranFactor);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                view.setTranslationY(tranFactor);</span><br><span class="line">            &#125;</span><br><span class="line">            view.setRotation(rotateFactor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该动画的效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/page1.png" alt="page1"><br><img src="http://7xii1s.com1.z0.glb.clouddn.com/page2.png" alt="page2"><br><img src="http://7xii1s.com1.z0.glb.clouddn.com/page3.png" alt="page3"></p><p>在滑动的过程总中左边和右边的会以此导向一个方向并且在Y方向上有一定位移，等到中间后图片的夹角会消失，而且会向上移动一定的距离。</p><p>好了，赶紧去体验一下ViewPager.PageTransformer吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目中要有个需求就是做出一个可以滑动的列表，类似于Paper效果的动画，期初设想的比较复杂，自定义监控ViewPager的OnScroll事件，然后再在onPageScrolled中根据&lt;code&gt;position&lt;/code&gt;, &lt;code&gt;positionOffset&lt;/code&gt;, &lt;code&gt;positionOffsetPixels&lt;/code&gt;等数据就算出滑动的百分比，通过滑动的百分比来控制动画播放的百分比。这样虽然也可以实现想要的效果，但是会很复杂，有许多中间状态需要我们自己计算和保存，维护起来非常麻烦。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单例模式的使用</title>
    <link href="http://tedyin.github.io/2014/12/14/singlton/"/>
    <id>http://tedyin.github.io/2014/12/14/singlton/</id>
    <published>2014-12-14T15:20:00.000Z</published>
    <updated>2016-02-29T09:30:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式大家应该已经很熟悉了，但是在使用单例模式的时候，我们经常会忽略一个问题，那就是多线程情况下的单例模式的使用。一般单例模式的实现会有下面两种，分别是懒汉式和饿汉式。<br><a id="more"></a></p><p>##懒汉式实现<br><figure class="highlight smali"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//懒汉式实现</span><br><span class="line">public class Singleton&#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> Singleton<span class="built_in"> instance </span>= null;    </span><br><span class="line">   <span class="keyword"> private</span> Singleton()&#123;&#125;</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> newInstance()&#123;</span><br><span class="line">        if(null == instance)&#123;</span><br><span class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword"> public</span> void doSomething()&#123;</span><br><span class="line">        // Do something ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##饿汉式<br><figure class="highlight smali"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//饿汉式</span><br><span class="line">public class Singleton&#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> Singleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</span><br><span class="line">   <span class="keyword"> private</span> Singleton()&#123;&#125;</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton newInstance()&#123;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword"> public</span> void doSomething()&#123;</span><br><span class="line">        // Do something ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>懒汉式和饿汉式的最大区别就是加载单例的时机的不同，也就是说空间和时间的问题。懒汉式是用空间换时间的典型，相反的饿汉式就是使用时间换空间的典型，上面的例子只是举了一个很简单的情况，假如这个单例对象很大非常占用内存，那么选择上述两种方式就会有很大的不同，要根据情况而确定到底使用哪一种。</p><p>但是不论选择上面的哪一种都会有一个问题那就是在多线程的情况下，如果是首次加载单例，就会出现生成多个单例的情况，这样如果是生成一个很大的单例对象的时候，加入这个单例对象的构造过程很复杂很耗时，那么在多线程情况下就会很容易出错，而且很耗内存，那么如何使用线程安全的单例模式呢？我们可以使用JVM自身来加载我们的单例模式，这样JVM自身在Load类的时候是线程安全的，因此我们可以利用这点写出线程安全的类。</p><p>##线程安全的类<br><figure class="highlight cpp"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">    <span class="comment">//内部类，在装载该内部类时才会去创建单利对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>利用JVM自身的特性之后，我们就再也不用担心多线程下单例模式的加载问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式大家应该已经很熟悉了，但是在使用单例模式的时候，我们经常会忽略一个问题，那就是多线程情况下的单例模式的使用。一般单例模式的实现会有下面两种，分别是懒汉式和饿汉式。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Irregular Shape</title>
    <link href="http://tedyin.github.io/2014/11/15/irregular-shape-1/"/>
    <id>http://tedyin.github.io/2014/11/15/irregular-shape-1/</id>
    <published>2014-11-15T15:52:00.000Z</published>
    <updated>2016-02-29T09:30:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>接下来几周的内容是一系列文章，来讲解Android中不规则图形的创建和使用。今天先来介绍一下圆角图片的实现。</p><p>有一个好消息要告诉大家，那就是在API 20中Android已经默认提供了圆角矩形的图片，RoundRectShape Drawable，但是不好的消息是大多数的人的手机版本都是20或者以上的，因此还是自己动手丰衣足食吧。<br><a id="more"></a><br>实现这种效果的方式有很多先来讨论第一种，最笨效果最差的实现。</p><h2 id="使用图层方式实现"><a href="#使用图层方式实现" class="headerlink" title="使用图层方式实现"></a>使用图层方式实现</h2><p>使用这种方法实现的话，我们需要使用到两张图片，一张是原图，另外一张就是与原图大小尺寸完全相同的模板图片比如下面两幅：</p><p><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog.jpg" alt="dog"><br><img src="http://7xii1s.com1.z0.glb.clouddn.com/mask.png" alt="mask"></p><blockquote><p>这里使用绿色的原因只是为了大家看的清楚而已。</p></blockquote><p>有了这两张图之后，我们可以加载这两张图片到内存中，然后使用<code>PoterDuffXfermode</code>类来将这两个图片合成为一张图片，就可以生成一个圆角图片的效果了。具体的代码如下：</p><figure class="highlight mipsasm"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">Bitmap </span>combineImage(<span class="keyword">Bitmap </span>srcBitmap, <span class="keyword">Bitmap </span>maskBitmap)&#123;</span><br><span class="line"><span class="keyword">Bitmap </span>resultBmp<span class="comment">;</span></span><br><span class="line">int width = srcBitmap.getWidth()&gt;maskBitmap.getWidth()?srcBitmap.getWidth():maskBitmap.getWidth()<span class="comment">;</span></span><br><span class="line">int height = srcBitmap.getHeight()&gt;maskBitmap.getHeight()?srcBitmap.getHeight():maskBitmap.getHeight()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">resultBmp = <span class="keyword">Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);</span></span><br><span class="line"><span class="keyword"></span>Paint paint = new Paint()<span class="comment">;</span></span><br><span class="line">paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode_SRC_ATOP))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Canvas canvas = new Canvas(resultBmp)<span class="comment">;</span></span><br><span class="line">canvas.drawBitmap(srcBitmap, <span class="number">0</span>, <span class="number">0</span>, null)<span class="comment">;</span></span><br><span class="line">    canvas.drawBitmap(maskBitmap, <span class="number">0</span>, <span class="number">0</span>, paint)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合成后的效果如下</p><p><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog_mask.jpg" alt="dog_mask"></p><p>OK，圆角矩形图片效果实现。但是这个方法实质上是最差劲的，它有如下几个缺点:</p><blockquote><ol><li>如果图片的形状有很多种，我们需要为每种图片都生成一张mask图片，这样效率会很低，而且工作量会加大很多。</li><li>适配性会变得很差，如果是圆角矩形图片，在大屏手机上拉伸回导致圆角效果失真。</li><li>还有个最大的问题，就是性能问题，如果图片尺寸很大，我们加载到内存中很可能出现内存溢出的情况，这样就得不偿失了。</li></ol></blockquote><p>因此这个方法的可用性较低，不推荐使用。但是此处为什么要介绍这个方法呢，最主要的是这个处理思路，我们可以使用上述的而方法来处理一些水印效果或者其他图片合成的效果，这样才是上述方法最好的使用方式。</p><p>接下来看看如何使用高效的方法创建圆角矩形。</p><p>##使用BitmapShader来创建圆角矩形<br>先来介绍一下使用BitmapShader的思路，其实这个很类似于我们平常使用Canvas画图形的方式，只是我们平时在画圆角矩形时填充Canvas的是纯色，这里为了得到圆角图片，我们可以使用上面的思路，将填充物由纯色改为我们要画的图片即可。具体的实现方式如下：<br><figure class="highlight armasm"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">private</span> <span class="keyword">Bitmap </span>processBitmap(<span class="keyword">Bitmap </span><span class="keyword">bitmap) </span>&#123;</span><br><span class="line"><span class="keyword">Bitmap </span><span class="keyword">bmp;</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">bmp </span>= <span class="keyword">Bitmap.createBitmap(bitmap.getWidth(), </span><span class="keyword">bitmap.getHeight(), </span><span class="keyword">Bitmap.Config.ARGB_8888);</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">BitmapShader </span>shader = new <span class="keyword">BitmapShader(bitmap, </span>Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)<span class="comment">;</span></span><br><span class="line">// 随机设置一个圆角的半径大小</span><br><span class="line">float raidus = getResources().getDisplayMetrics().density * <span class="number">6</span> + <span class="number">0</span>.<span class="number">5</span>f<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Canvas canvas = new Canvas(<span class="keyword">bmp);</span></span><br><span class="line"><span class="keyword"></span>Paint paint = new Paint()<span class="comment">;</span></span><br><span class="line">paint.setAntiAlias(true)<span class="comment">;</span></span><br><span class="line">paint.setShader(shader)<span class="comment">; // 将要填充的shader交给Paint</span></span><br><span class="line"></span><br><span class="line">RectF rect = new RectF(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">bitmap.getWidth(), </span><span class="keyword">bitmap.getHeight());</span></span><br><span class="line"><span class="keyword"></span>canvas.drawRoundRect(rect, raidus, raidus, paint)<span class="comment">;// 在RectF上绘制圆角图片</span></span><br><span class="line">return <span class="keyword">bmp;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></p><p>使用上述代码即可实现圆角矩形的绘制，绘制的结果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog2.png" alt="dog2"></p><p>同样的道理，我们可以使用上述方式，绘制出三角形，椭圆，多边形等各种各样的图片，思路和绘制圆角矩形是一样的。都是使用RectF来确定大体形状，然后使用带有BitmapShader的Paint来填充即可实现。</p><p>上面介绍了如何创建圆角矩形的方法，下面来介绍一下不规则图形的方法。</p><p>###创建聊天气泡背景效果的图片</p><p>创建这类图片的大体思路和上面是一致的，也是要使用<code>BitmapShader</code>这个类来进行。实现思路如下，我们可以先创建一个圆角矩形的图片，然后再在这个圆角矩形的基础之上绘制一个三角形，就可以实现带有气泡效果的图片了。现在已经知道了如何去画一个圆角矩形，那么一半工作已经算是完成了，下来要做的就是再绘制出一个三角形，然后和圆角矩形拼接在一起即可。但是现在有一个问题，<code>Canvas</code>并没有提供画三角形的方法，我们怎么办呢？在Canvas中提供了两个基本方法<code>movetTo()</code>和<code>lineTo()</code>方法，这两个方法可以让我们移动画笔画出直线，这样的话我们就可以使用这两个方法来自己动手画出三角形了（其实和Canvas封装的方法一样，只是要自己动手，显得有些麻烦）。是不是觉得很爽呢？其实这样做是有问题的，这样做智能画出一个三角形的轮廓，不会填充成一个完整的三角形。幸亏另外一个类也支持这些方法，那就是<code>Path</code>类，我们可以使用<code>Path</code>类画出一个路径，然后使用<code>Shader</code>来填充这个路径所包围的空间（路径类似于PhotoShop中的选区的概念）。有了这么一个牛逼的类，理论上讲我们是什么都可以画出来的，只要你能勾勒出那个路径，我们就能画出来。</p><p>好了，废话那么多下来看看如何用代码来是想上述气泡图片。</p><p>首先来画三角形的路径</p><figure class="highlight pony"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 新建一个Path类</span></span><br><span class="line"><span class="type">Path</span> triangle = <span class="function"><span class="keyword">new</span> <span class="title">Path</span>();</span></span><br><span class="line"><span class="function"><span class="comment">// 下来从0点开始一次画三条线，最终首尾相连，形成一个三角形</span></span></span><br><span class="line"><span class="function"><span class="title">triangle</span>.<span class="title">moveTo</span>(<span class="number">0</span>, <span class="type">TRIANGLE_OFFSET</span>);</span></span><br><span class="line"><span class="function"><span class="title">triangle</span>.<span class="title">lineTo</span>(<span class="type">TRIANGLE_WIDTH</span>,</span></span><br><span class="line"><span class="function">    <span class="type">TRIANGLE_OFFSET</span> - (<span class="type">TRIANGLE_HEIGHT</span> / <span class="number">2</span>));</span></span><br><span class="line"><span class="function"><span class="title">triangle</span>.<span class="title">lineTo</span>(<span class="type">TRIANGLE_WIDTH</span>,</span></span><br><span class="line"><span class="function">    <span class="type">TRIANGLE_OFFSET</span> + (<span class="type">TRIANGLE_HEIGHT</span> / <span class="number">2</span>));</span></span><br><span class="line"><span class="function"><span class="comment">// 然后close这个Path，这样一个三角形的Path就绘制完成了</span></span></span><br><span class="line"><span class="function"><span class="title">triangle</span>.<span class="title">close</span>();</span></span><br></pre></td></tr></table></figure><p>画完三角形的Path后，下面要做的就是，将该路径所围成的图像画在圆角矩形上，然后再用Shader填充即可。<br>完整代码如下<br><figure class="highlight processing"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">float</span> RADIUS_FACTOR = <span class="number">8.0</span>f;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> TRIANGLE_WIDTH = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> TRIANGLE_HEIGHT = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> TRIANGLE_OFFSET = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Bitmap processImage(Bitmap bitmap) &#123;</span><br><span class="line">    Bitmap bmp;</span><br><span class="line"></span><br><span class="line">    bmp = Bitmap.createBitmap(bitmap.getWidth(),</span><br><span class="line">        bitmap.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">    BitmapShader <span class="built_in">shader</span> = <span class="keyword">new</span> BitmapShader(bitmap,</span><br><span class="line">        BitmapShader.TileMode.CLAMP,</span><br><span class="line">        BitmapShader.TileMode.CLAMP);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> radius = Math.<span class="built_in">min</span>(bitmap.getWidth(),</span><br><span class="line">        bitmap.getHeight()) / RADIUS_FACTOR;</span><br><span class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(bmp);</span><br><span class="line">    Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">    paint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">    paint.setShader(<span class="built_in">shader</span>);</span><br><span class="line"></span><br><span class="line">    RectF <span class="built_in">rect</span> = <span class="keyword">new</span> RectF(TRIANGLE_WIDTH, <span class="number">0</span>,</span><br><span class="line">        bitmap.getWidth(), bitmap.getHeight());</span><br><span class="line">    canvas.drawRoundRect(<span class="built_in">rect</span>, radius, radius, paint);</span><br><span class="line"></span><br><span class="line">    Path <span class="built_in">triangle</span> = <span class="keyword">new</span> Path();</span><br><span class="line">    <span class="built_in">triangle</span>.moveTo(<span class="number">0</span>, TRIANGLE_OFFSET);</span><br><span class="line">    <span class="built_in">triangle</span>.lineTo(TRIANGLE_WIDTH,</span><br><span class="line">        TRIANGLE_OFFSET - (TRIANGLE_HEIGHT / <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">triangle</span>.lineTo(TRIANGLE_WIDTH,</span><br><span class="line">        TRIANGLE_OFFSET + (TRIANGLE_HEIGHT / <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">triangle</span>.close();</span><br><span class="line">    canvas.drawPath(<span class="built_in">triangle</span>, paint);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终得到的效果图如下：</p><p><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog3.jpg" alt="dog3"></p><p>只要用好Path、Shader以及Canvas类，理论上什么图形都可以实现。</p><p>##终结<br>上面说了Path、Shader、Rect、Canvas等，下面我们就可以是用上述介绍的方法和类来实现一些更加复杂的图形，作为这篇文章的终结。下面我们用上述介绍的内容来绘制一张心形的图片。<br>首先说一下绘制心形图片的思路，其实这个思路和上面绘制图片的思路大同小异，最主要的思想就是使用Path画出路径，然后使用Shader来填充这个路径包围的部分。</p><p>大体上我们将绘制步骤分为下面4步</p><p>###创建好画布(Canvas)、画笔(Paint)以及要绘制图像的区域Bitmap<br><figure class="highlight mipsasm"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Bitmap </span><span class="keyword">bmp </span>= <span class="keyword">Bitmap.createBitmap(bitmap.getWidth(),</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">bitmap.getHeight(), </span><span class="keyword">Bitmap.Config.ARGB_8888);</span></span><br><span class="line"><span class="keyword">BitmapShader </span><span class="keyword">shader </span>= new <span class="keyword">BitmapShader(bitmap,</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">BitmapShader.TileMode.CLAMP,</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">BitmapShader.TileMode.CLAMP);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Canvas </span>canvas = new Canvas(<span class="keyword">bmp);</span></span><br><span class="line"><span class="keyword">Paint </span>paint = new Paint()<span class="comment">;</span></span><br><span class="line">paint.setAntiAlias(true)<span class="comment">;</span></span><br><span class="line">paint.setShader(<span class="keyword">shader);</span></span><br></pre></td></tr></table></figure><br>因为后面要绘制不规则图形路径，有一些需要计算的地方，因此我们需要将<code>bitmap</code>的宽高记录下来。<br><figure class="highlight arduino"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> <span class="built_in">width</span> = bitmap.getWidth();</span><br><span class="line"><span class="keyword">float</span> <span class="built_in">height</span> = bitmap.getHeight();</span><br></pre></td></tr></table></figure><br>保存好宽高后，下来需要初始化Path，Region以及Matrix，这些都会在绘制心形图案时用到。<br><figure class="highlight maxima"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Path oval = <span class="built_in">new</span> Path();</span><br><span class="line">Matrix <span class="built_in">matrix</span> = <span class="built_in">new</span> Matrix();</span><br><span class="line">Region <span class="built_in">region</span> = <span class="built_in">new</span> Region();</span><br><span class="line">RectF ovalRect = <span class="built_in">new</span> RectF(<span class="built_in">width</span> / <span class="number">8</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">width</span> - (<span class="built_in">width</span> / <span class="number">8</span>), <span class="built_in">height</span>);</span><br></pre></td></tr></table></figure></p><p>下面来开始绘制心形图案的第二步，先绘制一个椭圆，这个椭圆的高度与我们的<code>bitmap</code>的高度一样，宽度是<code>bimap</code>的四分之三，这个宽度是来决定心形图片的宽窄的，可自行定义。<br>下面来绘制椭圆Path<br><figure class="highlight arduino"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RectF ovalRect = <span class="keyword">new</span> RectF(<span class="built_in">width</span> / <span class="number">8</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">width</span> - (<span class="built_in">width</span> / <span class="number">8</span>), <span class="built_in">height</span>);</span><br><span class="line">oval.addOval(ovalRect, Path.Direction.CW);</span><br></pre></td></tr></table></figure><br>这个<code>oval</code>就是上面已经定义过的椭圆路径，在此处进行填充，这个路径渲染出来的效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog4.jpg" alt="dog4"></p><p>绘制出椭圆后，下来我们将其进行旋转，使用上面定义好的<code>Matrix</code>对象来完成旋转的操作：<br><figure class="highlight maxima"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">matrix</span>.postRotate(<span class="number">30</span>, <span class="built_in">width</span> / <span class="number">2</span>, <span class="built_in">height</span> / <span class="number">2</span>);</span><br><span class="line">oval.<span class="built_in">transform</span>(<span class="built_in">matrix</span>, oval);</span><br></pre></td></tr></table></figure></p><p>Matrix是一个很强大的类，我们可以借助它实现很多关于图片的操作。</p><p>旋转后的效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog5.jpg" alt="dog5"></p><p>有了这样的效果之后，下来要做的就是，用一个矩形路径和这个被旋转的椭圆合并出半个心形路径，然后填充这个半个心形路径就可以到半个心形图片。这里使用上面定义好的<code>Region</code>类，Region就是一个矩形类，我们用这个类和半个椭圆类结合起来就可以拼出半个心形的路径来，具体的拼接方法如下：<br><figure class="highlight arduino"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将oval椭圆的路径和矩形Region路径合并</span></span><br><span class="line">region.setPath(oval, <span class="keyword">new</span> Region((<span class="keyword">int</span>)<span class="built_in">width</span> / <span class="number">2</span>, <span class="number">0</span>,</span><br><span class="line">    (<span class="keyword">int</span>)<span class="built_in">width</span>, (<span class="keyword">int</span>)<span class="built_in">height</span>));</span><br><span class="line"><span class="comment">// 画出该路径</span></span><br><span class="line">canvas.drawPath(region.getBoundaryPath(), paint);</span><br></pre></td></tr></table></figure><br>画出后的效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog6.jpg" alt="dog6"></p><p>好了，这样就画出了半个心形图片，重复上面的操作就可以画出另外一半的心形图片了，方法如下：</p><figure class="highlight maxima"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">oval.addOval(ovalRect, Path.Direction.CW);</span><br><span class="line"><span class="built_in">matrix</span>.postRotate(-<span class="number">30</span>, <span class="built_in">width</span> / <span class="number">2</span>, <span class="built_in">height</span> / <span class="number">2</span>);</span><br><span class="line">oval.<span class="built_in">transform</span>(<span class="built_in">matrix</span>, oval);</span><br><span class="line"><span class="built_in">region</span>.setPath(oval,</span><br><span class="line">    <span class="built_in">new</span> Region(<span class="number">0</span>, <span class="number">0</span>, (int)<span class="built_in">width</span> / <span class="number">2</span>, (int)<span class="built_in">height</span>));</span><br><span class="line">canvas.drawPath(<span class="built_in">region</span>.getBoundaryPath(), paint);</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog7.jpg" alt="dog7"></p><p>总结：只要用好Path、Shader、RectF所有的图形都可以迎刃而解，但是有一点需要注意的就是，这些操作都是比较消耗性能的操作，所以使用的时候需要注意性能问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接下来几周的内容是一系列文章，来讲解Android中不规则图形的创建和使用。今天先来介绍一下圆角图片的实现。&lt;/p&gt;
&lt;p&gt;有一个好消息要告诉大家，那就是在API 20中Android已经默认提供了圆角矩形的图片，RoundRectShape Drawable，但是不好的消息是大多数的人的手机版本都是20或者以上的，因此还是自己动手丰衣足食吧。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
