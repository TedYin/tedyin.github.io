<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>TedYin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Half Programer">
<meta property="og:type" content="website">
<meta property="og:title" content="TedYin's Blog">
<meta property="og:url" content="http://www.tedyin.me/index.html">
<meta property="og:site_name" content="TedYin's Blog">
<meta property="og:description" content="Half Programer">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TedYin's Blog">
<meta name="twitter:description" content="Half Programer">
  
    <link rel="alternative" href="/atom.xml" title="TedYin&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xii1s.com1.z0.glb.clouddn.com/me.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">TedYin</a></h1>
		</hgroup>

		
		<p class="header-subtitle">快乐比生命更重要！</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/TedYin" title="github">github</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">TedYin</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xii1s.com1.z0.glb.clouddn.com/me.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">TedYin</h1>
			</hgroup>
			
			<p class="header-subtitle">快乐比生命更重要！</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/TedYin" title="github">github</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/29/hello-world/" class="article-date">
  	<time datetime="2016-02-29T01:31:18.000Z" itemprop="datePublished">2016-02-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/29/hello-world/">Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-elasticsearch-batch-processing" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/26/elasticsearch-batch-processing/" class="article-date">
  	<time datetime="2016-01-26T14:00:00.000Z" itemprop="datePublished">2016-01-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="ES的批处理"><a href="#ES的批处理" class="headerlink" title="ES的批处理"></a>ES的批处理</h3><ul>
<li>前面已经介绍了如何使用ES提供的REST API去做CRUD操作,但是这些操作都是单一的.今天来介绍一下ES中的批处理,可以批量CUD索引和文档<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST &apos;localhost:9200/bank/account/_bulk?pretty&apos; --data-binary &quot;@accounts.json&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>@accounts.json</code>是存在当前目录下的一个json文件,里面存储了一个josn数组,你可以让她存储任何结构相同的数组.</p>
</blockquote>
<p>所有的批量操作都是使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html" target="_blank" rel="external">_bluk API</a>来完成,上面的操作就是为<code>accounts.json</code>里面的数据建立索引.</p>
<ul>
<li>除了批量操作数据之外,ES还可以对一条或多条数据进行多步骤操作.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST &apos;localhost:9200/blog/article/_bulk?pretty&apos; -d &apos;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;title&quot;: &quot;batch bulk api title 1&quot; &#125;</span><br><span class="line">&#123;&quot;update&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;: &#123;&quot;title&quot;: &quot;batch bulk api title 2&quot; &#125;&#125;</span><br><span class="line">&#123;&quot;delete&quot;:&#123;&quot;_id&quot;:&quot;3&quot;&#125;&#125;</span><br><span class="line">&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的批量操作一共干了三件事情:</p>
<ol>
<li>将id是1的Document重新以新的数据重新索引,因此该Document的version会自增1</li>
<li>更新了id是2的Document中的<code>title</code>数据,只是更新数据,并不涉及到重新索引所以version不会变化</li>
<li>删除了id为3的文档<br>更多的批处理操作可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html" target="_blank" rel="external">Bulk API</a></li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/_batch_processing.html" target="_blank" rel="external">Elasticsearch Batch Processing</a><br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html" target="_blank" rel="external">Elasticsearch Bulk API</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-elasticsearch-crud" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/25/elasticsearch-crud/" class="article-date">
  	<time datetime="2016-01-25T02:22:00.000Z" itemprop="datePublished">2016-01-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/25/elasticsearch-crud/">Elasticsearch CRUD</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>有了对ES的基本概念后,下面要做的就是了解如何与ES进行交流,ES非常贴心的提供了一套REST API让大家与他进行交流.这些API能做的事情包括以下几点</p>
<ul>
<li>检查你的集群,节点以及索引的状态信息</li>
<li>管理你的集群,节点以及索引等的数据</li>
<li>执行高级的搜索操作等<br>总之有了这套REST API你几乎可以让ES干它所能干的所有事.</li>
</ul>
<h2 id="状态查询API"><a href="#状态查询API" class="headerlink" title="状态查询API"></a>状态查询API</h2><p>可以使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html" target="_blank" rel="external">_cat API</a>去查询集群节点索引等的状态.</p>
<h3 id="查询集群健康状态"><a href="#查询集群健康状态" class="headerlink" title="查询集群健康状态"></a>查询集群健康状态</h3><ol>
<li><code>clur localhost:9200/_cat/health?v</code>查看集群状态,返回结果里有一个<code>status</code>的状态,它有三个值<code>green</code>,<code>yellow</code>,<code>red</code></li>
</ol>
<blockquote>
<ul>
<li><p><code>green</code>表示一切OK,可以提供搜索服务</p>
</li>
<li><p><code>yellow</code>表示所有的索引及其他状态都正常,但是副本数据不完整,有些分片没有副本数据,但是可以提供正常的搜索服务</p>
</li>
<li><p><code>red</code> 表示部分数据丢失,能提供部分搜索服务</p>
</li>
</ul>
<p>如果你是在本机上跑一个单节点的集群,那么<code>status</code>会是<code>yellow</code>的是因为,如果是单个节点,ES创建索引时并不会真的去分配副本,因为将副本和分片放在同一个节点里是无意义的,所以此处会返回<code>yellow</code>给出警告,如果当有新的Node加入,并且副本被分配到了新的节点里,这个索引的<code>status</code>就会变成<code>green</code></p>
</blockquote>
<ol>
<li><code>curl localhost:9200/_cat/nodes?v</code>查看节点状态</li>
<li><code>curl localhost:9200/_cat/indices?v</code>查看索引状态`</li>
</ol>
<h2 id="索引和文档CRUD"><a href="#索引和文档CRUD" class="headerlink" title="索引和文档CRUD"></a>索引和文档CRUD</h2><h3 id="目标数据"><a href="#目标数据" class="headerlink" title="目标数据"></a>目标数据</h3><figure class="highlight plain"><figcaption><span>lang: json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;title&quot;: &quot;New version of Elasticsearch released!&quot;,</span><br><span class="line">      &quot;content&quot;: &quot;Version 1.0 released today!&quot;,</span><br><span class="line">      &quot;priority&quot;: 10,</span><br><span class="line">      &quot;tags&quot;: [&quot;announce&quot;, &quot;elasticsearch&quot;, &quot;release&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到JSON文档包含一组字段, <code>&quot;id&quot;: &quot;1&quot;</code>一个字段,<code>&quot;content&quot;: &quot;Version 1.0 released today!&quot;</code>另一个字段,他们都有各自的类型ES会识别出这些类型.</p>
<h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p>ES为我们提供了一个强大的<code>REST API</code>用来操作ES服务,使用下面的命令来为上面的数据建立索引</p>
<h4 id="手动指定文档唯一标识符"><a href="#手动指定文档唯一标识符" class="headerlink" title="手动指定文档唯一标识符"></a>手动指定文档唯一标识符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/blog/article/1 -d &apos;&#123;</span><br><span class="line">      &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;title&quot;: &quot;New version of Elasticsearch released!&quot;,</span><br><span class="line">      &quot;content&quot;: &quot;Version 1.0 released today!&quot;,</span><br><span class="line">      &quot;priority&quot;: 10,</span><br><span class="line">      &quot;tags&quot;: [&quot;announce&quot;, &quot;elasticsearch&quot;, &quot;release&quot;]</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>blog</code> <code>article</code> <code>1</code> 分别是我们建立的<code>索引</code>名称 <code>文档</code>名称 和<code>唯一标识符</code></p>
</blockquote>
<p>执行成功后的返回结果:<br><figure class="highlight plain"><figcaption><span>lang: json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;_index&quot;:&quot;blog&quot;,</span><br><span class="line">	&quot;_type&quot;:&quot;article&quot;,</span><br><span class="line">	&quot;_id&quot;:&quot;1&quot;,</span><br><span class="line">	&quot;_version&quot;:1,</span><br><span class="line">	&quot;_shards&quot;:</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;total&quot;:2,</span><br><span class="line">			&quot;successful&quot;:1,</span><br><span class="line">			&quot;failed&quot;:0</span><br><span class="line">		&#125;,</span><br><span class="line">	&quot;created&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>_index: 表示建立索引的名称<code>blog</code>(database name)</li>
<li>_type: 表示索引的类型 <code>article</code>(table name)</li>
<li>_Id: 表示文档的唯一标识符 <code>1</code> (可以理解为表的primary key)</li>
<li>_version: 表示版本信息,该值由ES维护,每次更新索引的时候<code>_version</code>会自动递增</li>
<li>_shards: 表示其分片信息</li>
</ul>
<blockquote>
<p>如果重复创建Id相同的Document时,只会由ES去更新Document,相应的<code>_version</code>也会递增</p>
</blockquote>
<h4 id="自动生成文档的唯一标识符"><a href="#自动生成文档的唯一标识符" class="headerlink" title="自动生成文档的唯一标识符"></a>自动生成文档的唯一标识符</h4><p>只需要将<code>put</code>操作换成<code>post</code>即可,ES会自动为我们的<code>Document</code>生成唯一的标识符.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/blog/article -d &apos;&#123;</span><br><span class="line">      &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;title&quot;: &quot;New version of Elasticsearch released!&quot;,</span><br><span class="line">      &quot;content&quot;: &quot;Version 1.0 released today!&quot;,</span><br><span class="line">      &quot;priority&quot;: 10,</span><br><span class="line">      &quot;tags&quot;: [&quot;announce&quot;, &quot;elasticsearch&quot;, &quot;release&quot;]</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p>返回结果:<br><figure class="highlight plain"><figcaption><span>lang: json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;_index&quot;:&quot;blog&quot;,</span><br><span class="line">	&quot;_type&quot;:&quot;article&quot;,</span><br><span class="line">	&quot;_id&quot;:&quot;AVJe9pBhG_DRWvBx76jq&quot;,</span><br><span class="line">	&quot;_version&quot;:1,</span><br><span class="line">	&quot;_shards&quot;:</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;total&quot;:2,</span><br><span class="line">			&quot;successful&quot;:1,</span><br><span class="line">			&quot;failed&quot;:0</span><br><span class="line">		&#125;,</span><br><span class="line">	&quot;created&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>上面<code>AVJe9pBhG_DRWvBx76jq</code>是由ES自动生成的文档的唯一标识</li>
</ul>
<h4 id="创建空的索引"><a href="#创建空的索引" class="headerlink" title="创建空的索引"></a>创建空的索引</h4><p>除了创建包含有文档和类型的索引之外,还可以穿件一个空的索引,里面不包含任何Document和Type<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST localhost:9200/empty_index</span><br></pre></td></tr></table></figure></p>
<p>返回结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;acknowledged&quot;:true&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>一般情况下我们不需要这么做,直接创建正常的索引就行了,如果索引里面没有数据,那么这个索引也是多余的.</li>
</ul>
<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>在更新文档的时候,ES并不是直接对已经经过索引的文档进行修改,而是删除旧的文档,并使用新的数据重新索引</p>
<ul>
<li><p>只更新<code>title</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST localhost:9200/blog/article/1/_update?pretty -d &apos;&#123;</span><br><span class="line">  &quot;doc&quot;: &#123; &quot;title&quot;: &quot;New Title&quot; &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新<code>title</code>, 并添加<code>author</code>字段.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST localhost:9200/blog/article/1/_update?pretty -d &apos;&#123;</span><br><span class="line">  &quot;doc&quot;: &#123; &quot;title&quot;: &quot;New Title again !&quot;, &quot;author&quot;: &quot;ES&quot; &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>删除之前创建的index: blog, type: article, id: 1 的文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XDELETE localhost:9200/blog/article/1</span><br></pre></td></tr></table></figure></p>
<p>返回结果:<br><figure class="highlight plain"><figcaption><span>lang: json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;found&quot;:true,</span><br><span class="line">	&quot;_index&quot;:&quot;blog&quot;,</span><br><span class="line">	&quot;_type&quot;:&quot;article&quot;,</span><br><span class="line">	&quot;_id&quot;:&quot;1&quot;,</span><br><span class="line">	&quot;_version&quot;:3,</span><br><span class="line">	&quot;_shards&quot;:&#123;</span><br><span class="line">		&quot;total&quot;:2,</span><br><span class="line">		&quot;successful&quot;:1,</span><br><span class="line">		&quot;failed&quot;:0</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XDELETE localhost:9200/blog/article/1</span><br></pre></td></tr></table></figure>
<p>返回结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;acknowledged&quot;:true&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>与创建空索引成功的返回值一样,只返回这个?,是不是意味着ES并没有真正的删除索引内部的数据呢?而是对那些数据进行了标记,然后再以后创建新的索引的时候直接覆盖掉这些数据呢?这个需要进一步研究一下.</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上ES的REST API 都是按照下面的协议来定义的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X&lt;REST Verb&gt; &lt;Node&gt;:&lt;Port&gt;/&lt;Index&gt;/&lt;Type&gt;/&lt;ID&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html" target="_blank" rel="external">Elasticsearch Getting Started</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-elasticsearch-basic-concepts" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/24/elasticsearch-basic-concepts/" class="article-date">
  	<time datetime="2016-01-24T12:22:00.000Z" itemprop="datePublished">2016-01-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/24/elasticsearch-basic-concepts/">Elasticsearch Basic Concepts</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Cluster-集群"><a href="#Cluster-集群" class="headerlink" title="Cluster 集群"></a>Cluster 集群</h4><p>Cluster 包含了多个运行ES的节点,每个集群都有一个唯一的名字,用来区分不同的集群,含有相同<code>cluster name</code>的<code>Node</code>属于同一个集群</p>
<h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><p>运行ES的一个实例</p>
<h4 id="Index-索引"><a href="#Index-索引" class="headerlink" title="Index 索引"></a>Index 索引</h4><p>相当于MySql 的一个Database,他是Document的集合,每个索引都由他的名称来区分,而且他的名称全是小写的.这个名称可以代表索引,去进行查询更新删除等操作</p>
<h4 id="Type-类型"><a href="#Type-类型" class="headerlink" title="Type 类型"></a>Type 类型</h4><p>可以理解为Database中的一张表,在一个索引内可以定义多个Type,每一个Type都相当于是对整个索引的一个逻辑分类,就像在一个Database中可以定义多个table,每个table都相当于Database中的一个逻辑分类一样.</p>
<h4 id="Document-文档"><a href="#Document-文档" class="headerlink" title="Document 文档"></a>Document 文档</h4><p>相当于Table中的一行记录(元组),一个Document是ES中可以被索引的最基本的数据单元,就像Database里每条记录也是一个最基本的单元.每个Document可以包含一个或多个Field.</p>
<h4 id="Field-字段"><a href="#Field-字段" class="headerlink" title="Field 字段"></a>Field 字段</h4><p>与MySQL中的字段类似,但是ES中的字段是带有值的</p>
<h4 id="Shards-amp-Replicas-分片-amp-副本"><a href="#Shards-amp-Replicas-分片-amp-副本" class="headerlink" title="Shards &amp; Replicas  分片&amp;副本:"></a>Shards &amp; Replicas  分片&amp;副本:</h4><p>当一个Node上的索引大到该Node的磁盘无法存储这个索引或者索引太大导致搜索效率低下的时候,就可以将这个庞大的索引分成多个分片(Shards),存储在多个Node上,这样就解决了无法存储和搜索低效的问题,因此分片存在有两个中要的原因:</p>
<ul>
<li>可以对庞大的索引进行水平切分,这个操作类似于对大表的水平切分</li>
<li>因为切分成了多个分片,因此就可以并行去进行查询,这样就可以提高查询效率.<br>对于Shards怎样去分发到多个Node,以及搜索完成后讲数据汇总到发起请求的节点,这些工作都是由ES来自动完成的,不需要我们去关心.</li>
</ul>
<p>因为服务器存在一定的宕机风险,因此如果所有的Shard都放在某个Node上,如果宕机了,索引就会丢失,因此为了解决这个问题需要对Shards进行备份生产Replica Shards 也叫做Replicas, Replica的主要作用有两个:</p>
<ul>
<li>解决Node宕机后,索引丢失的问题</li>
<li>提高搜索效率,因为Replicas不会放下一个Node下,所以处理搜索请求的时候多个节点可以并行对Replicas进行查询,提高吞吐量.<br>总得来说,每个Index可以被切分成多个分片,每个分片可以有0个或多个副本,在创建索引的时候可以指定分片数和副本数,在成功创建索引后,依然可以通过ES提供的<code>_cat</code>API来修改副本数,但是不能去修改分片数.</li>
</ul>
<blockquote>
<p>一个ES的Shard就是一个Lucene的索引,每个Lucene索引可以存储Integer.MAX_VALUE-128 = 2,147,483,519个Document. 默认情况下一个ES索引有5个分片,每个分片有1个副本,也就是说当你创建一个索引时会产生5个分片,每个分片会有1个副本,总共就相当于1个索引有10个分片.</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/_basic_concepts.html" target="_blank" rel="external">Elasticsearch Basic Concepts</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-android-issue" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/03/android-issue/" class="article-date">
  	<time datetime="2015-05-03T14:53:00.000Z" itemprop="datePublished">2015-05-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/03/android-issue/">Android开发中遇到的小问题汇总</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在实际的项目开发过程中，经常会遇到一些莫名其妙的问题，或者很容易忽略的但是会造成很多麻烦的小问题，这篇帖子用来记录下这些问题，并给出注意事项或者解决方法，后续会不断更新所遇到的问题和解决方法。</p>
<ol>
<li>Fragment中使用onActivityResult方法无效不能有效的回调</li>
</ol>
<p>###解决方法<br>在Fragment中不要使用getActivity().startActivityForResult()方法去启动Activity，而应该直接使用startActivity方法去启动Activity，否则会被挂载Fragment的Activity中的onActivityResult的方法截获，导致Fragment的onActivityResult方法无法被回调。</p>
<p>###参考<br><a href="http://stackoverflow.com/questions/6147884/onactivityresult-not-being-called-in-fragment" target="_blank" rel="external">参考Stackoverflow</a></p>
<ol>
<li>ViewPager.setCurrentItem(0)后onPageSelect方法没有被触发</li>
</ol>
<p>###解决方法<br>调用完setCurrentItem(0)后再手动调用加载函数。原因是ViewPager内部的mCurrentItem默认值为0，设置了setCurrentItem（0）之后dispatchSelect为false认为已经调用过了onPageSelect方法，因此在第一次调用完setCurrentItem(0)时无效。</p>
<p>###参考<br><a href="http://stackoverflow.com/questions/11794269/onpageselected-isnt-triggered-when-calling-setcurrentitem0" target="_blank" rel="external">参考Stackoverflow</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jcenter" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/02/jcenter/" class="article-date">
  	<time datetime="2015-05-02T14:22:22.000Z" itemprop="datePublished">2015-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/02/jcenter/">使用Gradle将代码上传到JCenter</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-how-to-use-jenv" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/26/how-to-use-jenv/" class="article-date">
  	<time datetime="2015-04-26T12:22:00.000Z" itemprop="datePublished">2015-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/26/how-to-use-jenv/">How To Use Jenv To Master Your Java Environnement</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>对于一个Java开发者来说，系统上安装多个Java版本是很常见的事，但是在各个版本之间进行切换是一件非常痛苦的事情，今天向大家介绍一个工具<code>Jenv</code>，用它来终结我们的Java版本管理之痛。</p>
</blockquote>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Jenv的作用类似于rbenv，只是rbenv是用来管理系统上的不同Ruby版本的。Jenv运行在Linux或者Mac上，不能在Windows上使用（建议Win的用户转向Linux或者Mac）。</p>
<blockquote>
<p>本文以Mac系统位例进行介绍。</p>
</blockquote>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li><p>将代码下载到<code>~/.jenv</code>目录下</p>
<figure class="highlight plain"><figcaption><span>lang: bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/gcuisinier/jenv.git ~/.jenv</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>~/.jenv/bin</code>加入到<code>$PATH</code>环境变量中</p>
</li>
<li><p>添加初始化Jenv的脚本到环境变量中</p>
<figure class="highlight plain"><figcaption><span>lang: bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;eval &quot;$(jenv init -)&quot;&apos; &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启命令行，使PATH的设置生效，现在可已使用jenv来管理JDK版本了。</p>
</li>
</ol>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>下面介绍几个最常用的Jenv命令</p>
<blockquote>
<ol>
<li><p><code>jenv version</code> 显示当前正在使用的JDK版本号</p>
</li>
<li><p><code>jenv versions</code> 显示当前系统上已将安装的所有JDK版本号</p>
</li>
<li><p><code>jenv local [java version]</code> 指定当前目录下要使用的JDK版本号，只在该目录及其子目录内有效，在该目录以外还是使用原有的JDK版本。</p>
</li>
<li><p><code>jenv global [java version]</code> 指定全局的JDK版本号，在整个系统中有效。</p>
</li>
<li><p><code>jenv info java</code> 检查<code>JAVA_HOME</code>设置是否有效，如果有效会输出<code>JAVA_HOME</code>的路径</p>
</li>
<li><p><code>jenv local --unset</code> 消除jenv local的设置，恢复使用默认的JDK版本</p>
</li>
</ol>
</blockquote>
<h1 id="该项目Github地址"><a href="#该项目Github地址" class="headerlink" title="该项目Github地址"></a>该项目Github地址</h1><p><a href="https://github.com/gcuisinier/jenv" target="_blank" rel="external">Jenv</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-parcelable-vs-serializable" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/03/parcelable-vs-serializable/" class="article-date">
  	<time datetime="2015-04-03T14:28:00.000Z" itemprop="datePublished">2015-04-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/03/parcelable-vs-serializable/">Parcelable Vs Serializable</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天说一下对象序列化时的两个接口<code>Serializable</code>和<code>Parcelable</code>，前者是Java中的老面孔了，大家也都非常熟悉了，后者是Android提供的新面孔，既然Java本身就有序列化的接口为什么Android还要重新造轮子呢？当然Google也不是傻子，肯定是前面那个轮子不能满足他们的要求，所以他们才重新造出了<code>Parcelable</code>这个接口。</p>
<h2 id="Serializable接口的使用"><a href="#Serializable接口的使用" class="headerlink" title="Serializable接口的使用"></a>Serializable接口的使用</h2><p>首先来看看<code>Serializable</code>如何使用。<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SerializableClass implements Serializable&#123;</span><br><span class="line">	String name;</span><br><span class="line">	int age;</span><br><span class="line">	float height;</span><br><span class="line">	List&lt;Skill&gt; skillList;</span><br><span class="line"></span><br><span class="line">	static class Skill implements Serializable&#123;</span><br><span class="line">		String skillName;</span><br><span class="line">		boolean gotIt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，这样就可以直接将这个类序列化后使用Intent/Bundle进行传递了。使用起来非常简单，只需要实现<code>Serializable</code>接口即可。<code>Serializable</code>接口是一个标志接口，只要实现了这个接口，你就不需要做任何操作，Java会使用Reflection(反射技术)将类进行序列化和反序列化，非常的简单方便。但是有一个问题就是<strong>效率太低</strong>,在序列化和反序列化过程中会创建许多中间对象，会使得GC多次被调用，从而影响到程序的性能，我们都知道在GC被触发后进行垃圾回收的过程中，线程是被挂起的，APP会处于无响应状态，尽管这个过程持续的时间很短很短只有几十毫秒，但如果多次重复必定会影响到用户体验，一次Google的大牛们就不淡定了，这么差的性能怎么忍得了？但是如何破呢？答案就是<code>Parcelable</code>，他们造出了<code>Parcelable</code>来解决这个问题。</p>
<p>##Parcelable接口的使用<br>和上面一样，还是先来看看<code>Parcelable</code>接口是如何使用的。<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class ParcelableClass implements Parcelable&#123;</span><br><span class="line">	String name;</span><br><span class="line">	int age;</span><br><span class="line">	float height;</span><br><span class="line">	List&lt;Skill&gt; skillList;</span><br><span class="line"></span><br><span class="line">	static final Parcelable.Creator&lt;ParcelableClass&gt; CREATOR </span><br><span class="line">		= new Parcelable.Creator&lt;ParcelableClass&gt;()&#123;</span><br><span class="line"></span><br><span class="line">		@Overried</span><br><span class="line">		ParcelableClass createFromParcel(Parcel in)&#123;</span><br><span class="line">			return new ParcelableClass(in);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Overried</span><br><span class="line">		ParcelableClass[] newArray(int size)&#123;</span><br><span class="line">			return new ParcelableClass[size];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ParcelableClass(Parcel in)&#123;</span><br><span class="line">		this.name = in.readString();</span><br><span class="line">		this.age = in.readInt();</span><br><span class="line">		this.height = in.readFloat();</span><br><span class="line">		this.skillList = new ArrayList&lt;Skill&gt;();</span><br><span class="line">		in.readTypedList(skillList,Skill.CREATOR);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Overried</span><br><span class="line">	void writeToParcel(Parcel dest, int flags)&#123;</span><br><span class="line">		dest.writeString(this.name);</span><br><span class="line">		dest.writeInt(this.age);</span><br><span class="line">		dest.writeFloat(this.height);</span><br><span class="line">		dest.writeTypedList(this.skillList);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Overried</span><br><span class="line">	int describeContents()&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static class Skill implements Parcelable&#123;</span><br><span class="line">		String skillName;</span><br><span class="line">		boolean gotIt;</span><br><span class="line"></span><br><span class="line">		static final Parcelable.Creator&lt;Skill&gt; CREATOR </span><br><span class="line">			= new Parcelable.Creator&lt;Skill&gt;()&#123;</span><br><span class="line"></span><br><span class="line">			@Overried</span><br><span class="line">			Skill createFromParcel(Parcel in)&#123;</span><br><span class="line">				return new Skill(in);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			@Overried</span><br><span class="line">			Skill[] newArray(int size)&#123;</span><br><span class="line">				return new Skill[size];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Skill(Parcel in)&#123;</span><br><span class="line">			this.skillName = in.readString();</span><br><span class="line">			this.gotIt = in.readBoolean();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Overried</span><br><span class="line">		int describeContents()&#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Overried</span><br><span class="line">		void writeToParcel(Parcel dest, int flags)&#123;</span><br><span class="line">			dest.writeString(skillName);</span><br><span class="line">			dest.writeBoolean(gotIt ? 1 : 0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static class Skill implements Parcelable&#123;</span><br><span class="line">		String skillName;</span><br><span class="line">		boolean gotIt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>终于写完了，这比刚才使用<code>Serializable</code>接口时的代码长了好几倍，代码的可读性也大不如刚刚的代码，但是为了性能上的提升，这么做也是值得的，与性能相比代码多点难点又算得了什么呢？何况这个代码也不是很难，而且是有迹可循的:</p>
<blockquote>
<ol>
<li>每个实现了Parcelable的接口都需要实现一个<code>Parcelable.Creator</code>对象。</li>
<li>提供一个以Parcel为参数的构造函数。</li>
<li>实现<code>describeContents()</code>方法</li>
<li>实现<code>writeToParcel(Parcel dest, int flags)</code>方法。</li>
</ol>
</blockquote>
<p>这样就OK了,下面来看看废了一番周折写出来的序列化方法到底比原生的好了多少，有图有真相！！<br><img src="http://www.tedyin.me/images/parcelable_vs_serializable.png" alt="parcelable"></p>
<p>OMG !这差距，使用<code>Parcelable</code>虽然复杂点，但是这性能提升，真是值了！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.developerphil.com/parcelable-vs-serializable/" target="_blank" rel="external">Parcelable vs Serializable</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-tools-usage" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/28/tools-usage/" class="article-date">
  	<time datetime="2015-03-28T14:29:00.000Z" itemprop="datePublished">2015-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/28/tools-usage/">Android Tools Attribute</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android tools提供了一组非常有用的属性方法来方便我们开发，tools所指定的所有属性在打包的时候都不会打包到APK里，它只是辅助开发的一组工具属性，本文基于Android Studio，快捷建使用Mac OSX 10.5+ KeyMap，下面以IDE来表示Android Studio。</p>
<p>##tools : context<br>使用context属性来告诉IDE，这个布局文件是哪个Activity的布局文件，所以在预览的时候需要根据这个Activity的主题属性来显示，而不是使用默认的主题来进行预览。除了这个作用之外还有另外一点，在IDE中使用Go to Related files（快捷键CMD+Ctrl+Up）功能来帮助找到相关的布局文件。context属性在填写的时候，需要填上Activity的完整包名。<br><img src="http://www.tedyin.me/images/tools_1.png" alt="p1"></p>
<p>##tools:menu<br>如果你已经使用了context属性指定过了对应的Activity，那么IDE默认会自己去检查OnCreateOptionsMenu里面使用了哪个menu布局，然后在预览的时候加载该布局。使用menu属性可以覆盖上述默认操作。如果不想显示menu则可以设置tools:menu=“”即可。另外还可以使用menu属性定义多个菜单资源，如果不想显示menu则可以给menu属性赋值为空，例如：tools:menu=“”即可。另外，还可以在预览的时预览任意个你想看到的menu菜单项，而不是直接预览menu布局里面的内容。实现这样的效果十分简单，只需要在menu后面写上对应的菜单项的Id并用“ , ”隔开即可。举个例子：<br><code>tools:menu=“action_search,action_add&quot;</code><br>还有一点需要注意的就是，在使用Theme.AppCompat时，menu这个属性不起作用。</p>
<p>##tools:actionBarNavMod<br>使用该属性告诉IDE我要显示的ActionBar的模式，包含了三个选项standard、tabs、list，该属性只有在Holo主题下有用，在其他主题下无法使用。</p>
<p>##tools:listitem，tools:listheader，tools:listfooter<br>从名字就可以看出他们的意思，这是一组属性，我们可以使用这些属性分别告诉IDE一下信息:</p>
<ol>
<li>listitem是告诉IDE这个列表里面的Item内容是什么，在预览的时候可以和Item一起预览，而不是傻傻的默认显示一行文字。</li>
<li>listheader是告诉IDE这个列表的头部是什么，并一起预览</li>
<li>listfooter是告诉IDE这个列表的底部是什么，并一起预览需要注意的一点是，listheader和listfooter对GridView是没有效果的。</li>
</ol>
<p>##tools:layout<br>用这个属性告诉IDE，这个Layout在预览的时候应该显示什么东西，而不是显示一片空白。<br><img src="http://www.tedyin.me/images/tools_2.png" alt="p2"></p>
<p>##补充：</p>
<ol>
<li>tools:text属性用来显示要预览的文字，预览时会覆盖text属性的内容。</li>
<li>tools:src属性用来显示要预览的图片资源。</li>
</ol>
<p>#tools 中对Lint处理的属性</p>
<p>##tools:ignore<br>该属性对那些有“强迫症”的患者非常有用，经常我们在布局文件中写完ImageView后，都会提示少了Description，每次看见那个小黄线的提示就会觉得非常别扭，但是有了这个属性，就不用担心了，只要在ImageView的属性设置后面加上tools:ignore=“contentDescription”即可立马解决问题。除了上述用法外，还可以用在别的想忽略警告的地方。</p>
<p>##tools:targetApi<br>这个属性从名字就可以看出是用来指定API的。如果我们的minSdk是11，但是我们用了一个在API 14后才有的控件，在布局编辑器里就会报错，那么在报错的控件下面使用targetApi并指定对应的API即可解决问题。<br><figure class="highlight plain"><figcaption><span>lang: xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">android:color=&quot;@color/accent_color&quot;</span><br><span class="line">tools:targetApi=&quot;LOLLIPOP&quot; /&gt;</span><br></pre></td></tr></table></figure><br>好了，tools的用法基本就介绍完了，详细的列表可以<a href="http://tools.android.com/tech-docs/tools-attributes" target="_blank" rel="external">参考这里</a></p>
<p>##参考<br><a href="https://medium.com/sebs-top-tips/tools-of-the-trade-part-2-b91271892d10" target="_blank" rel="external">英文</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0309/2567.html" target="_blank" rel="external">中文版</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-android-view-lifecycle" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/11/android-view-lifecycle/" class="article-date">
  	<time datetime="2015-03-11T13:00:00.000Z" itemprop="datePublished">2015-03-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/11/android-view-lifecycle/">Android View Lifecycle</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Android开发中了解各个组件的生命周期非常重要，网上已经有许多关于Activity、Fragment等的生命周期的介绍了，今天来介绍一下View的生命周期。</p>
<p>##什么是View<br>先来看看官方文档的解释：</p>
<blockquote>
<p>This class represents the basic building block for user interface components. A View occupies a rectangular area on the screen and is responsible for drawing and event handling. View is the base class for widgets, which are used to create interactive UI components (buttons, text fields, etc.). The ViewGroup subclass is the base class for layouts, which are invisible containers that hold other Views (or other ViewGroups) and define their layout properties.</p>
</blockquote>
<p>也就是说View是最基础的UI组件，所有的其他的UI组件都是从View类中衍生出来的，可见View的地位是多么的高，所以需要掌握View的各个细节。</p>
<p>##View生命周期中用到的方法</p>
<p>###1. View的创建期：<br>使用View的构造函数进行创建，在这个过程中，如果有自定义的属性的话，也需要在这个期间进行处理。当View和他的子View全部从XML中inflate结束后，会调用<code>View#onFinishInflate()</code>方法。</p>
<p>###2. View的布局过程<br>整个布局过程做的就是处理View的大小和位置相关的信息。<br><code>View#onMesure()</code>方法的作用就是计算每个控件在屏幕上的尺寸大小。<code>View#onLayout</code>方法的作用就是设置所有控件的大小和位置。<br><code>View#onSizeChanged</code>方法的作用是当View的大小改变会调用此方法。</p>
<p>###3. View的渲染<br>View的渲染过程会调用onDraw方法。</p>
<p>###4. View对事件的处理<br>处理View事件方法有<code>View#onKeyDown()</code>当设备的物理按键按下后会触发该方法；<code>View#onKeyUp()</code>当设备的物理按键弹起的时候就会触发该方法；<code>View#onTrackballEvent()</code>当轨迹球被触动的时候会触发该方法；<br><code>View#onTouchEvent()</code>当设备的屏幕有来自用户的触摸操作时会回调该法，比如某些滑动操作我们就可以在该方法中拦截处理，可以根据用户的不同滑动距离和滑动速度等用户操作，给出许多不同的反馈，提供更好的用户体验。</p>
<p>###5. View对焦点的处理<br>处理焦点相关事件的回调方法为<code>View#onFocusChanged()</code>当控件的焦点发生改变，会触发该方法。</p>
<p>###6. View在根节点上的挂载和删除<br>当View通过构造函数创建出来后，如果不挂载到Window上时，是无法显示出来的。当View要挂载到Window上时会调用<code>Veiw#onAttachedToWindow()</code>方法；当View被销毁后要从Window上去除时会调用<code>View#onDetachedFromWindow()</code>方法；当Window隐藏或者可见时会调用<code>View#onWindowVisibilityChanged()</code>方法。通过这几个方法我们可以处理一些初始化的操作，和一些在View被销毁后进行的内存回收或者善后的工作。</p>
<p>##View的生命周期示意图<br><img src="http://www.tedyin.me/images/view_lifecycle.png" alt="view_lifecycle"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-android-ui-tips" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/18/android-ui-tips/" class="article-date">
  	<time datetime="2015-01-18T15:30:00.000Z" itemprop="datePublished">2015-01-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/18/android-ui-tips/">Android UI Tips</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###Tips:</p>
<ol>
<li>使用SparseArray代替HashMap等容器类。</li>
<li>能复用时一定要复用，不能复用时尽量复用。复用一切！</li>
<li>使用静态工厂方法去获取对象（使用Message时不要自己去new Message，要使用Message.obtain()方法去获取）这样可以减少不必要的对象，复用已有的对象。</li>
<li>使用一个全局变量代替多个临时变量。</li>
<li>使用Handler、AsyncTask、Loader、IntentService处理异步任务，而非仅使用java.concurrent包</li>
<li>给你的线程一个优先级，如果是处理后台任务的线程，设置他的优先级为Background。</li>
<li>对于ListView的3种状态进行处理，从而优化代码，提升性能。(例如在滑动过程中停止图片的加载，等恢复正常后再继续加载图)</li>
</ol>
<p>###总结:</p>
<ol>
<li>不要阻塞Main Thread（UI Thread）</li>
<li>扁平化你的布局层次（能用一个Layout最好，可以使用merge代替FrameLayout）</li>
<li>能复用就尽量复用一切可复用的东西。</li>
<li>延迟加载一些不需要立即使用的内容。</li>
<li>对你的Thread或者Task设置优先级，UI任务和Thread永远是最高级。</li>
</ol>
<p>###参考:</p>
<p><a href="https://speakerdeck.com/cyrilmottier/optimizing-android-ui-pro-tips-for-creating-smooth-and-responsive-apps" target="_blank" rel="external">Android UI Tips</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 TedYin
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>