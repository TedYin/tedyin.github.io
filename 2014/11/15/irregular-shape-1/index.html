<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Irregular Shape | TedYin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="接下来几周的内容是一系列文章，来讲解Android中不规则图形的创建和使用。今天先来介绍一下圆角图片的实现。
有一个好消息要告诉大家，那就是在API 20中Android已经默认提供了圆角矩形的图片，RoundRectShape Drawable，但是不好的消息是大多数的人的手机版本都是20或者以上的，因此还是自己动手丰衣足食吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="Irregular Shape">
<meta property="og:url" content="http://www.tedyin.me/2014/11/15/irregular-shape-1/index.html">
<meta property="og:site_name" content="TedYin's Blog">
<meta property="og:description" content="接下来几周的内容是一系列文章，来讲解Android中不规则图形的创建和使用。今天先来介绍一下圆角图片的实现。
有一个好消息要告诉大家，那就是在API 20中Android已经默认提供了圆角矩形的图片，RoundRectShape Drawable，但是不好的消息是大多数的人的手机版本都是20或者以上的，因此还是自己动手丰衣足食吧。">
<meta property="og:image" content="http://7xii1s.com1.z0.glb.clouddn.com/dog.jpg">
<meta property="og:image" content="http://7xii1s.com1.z0.glb.clouddn.com/mask.png">
<meta property="og:image" content="http://7xii1s.com1.z0.glb.clouddn.com/dog_mask.jpg">
<meta property="og:image" content="http://7xii1s.com1.z0.glb.clouddn.com/dog2.png">
<meta property="og:image" content="http://7xii1s.com1.z0.glb.clouddn.com/dog3.jpg">
<meta property="og:image" content="http://7xii1s.com1.z0.glb.clouddn.com/dog4.jpg">
<meta property="og:image" content="http://7xii1s.com1.z0.glb.clouddn.com/dog5.jpg">
<meta property="og:image" content="http://7xii1s.com1.z0.glb.clouddn.com/dog6.jpg">
<meta property="og:image" content="http://7xii1s.com1.z0.glb.clouddn.com/dog7.jpg">
<meta property="og:updated_time" content="2016-02-29T09:30:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Irregular Shape">
<meta name="twitter:description" content="接下来几周的内容是一系列文章，来讲解Android中不规则图形的创建和使用。今天先来介绍一下圆角图片的实现。
有一个好消息要告诉大家，那就是在API 20中Android已经默认提供了圆角矩形的图片，RoundRectShape Drawable，但是不好的消息是大多数的人的手机版本都是20或者以上的，因此还是自己动手丰衣足食吧。">
<meta name="twitter:image" content="http://7xii1s.com1.z0.glb.clouddn.com/dog.jpg">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xii1s.com1.z0.glb.clouddn.com/me.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">TedYin</a></h1>
		</hgroup>

		
		<p class="header-subtitle">快乐比生命更重要</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/TedYin" title="github">github</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/TedYin" title="twitter">twitter</a>
					        
								<a class="mail" target="_blank" href="mailto:tedworld.time@gmail.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/elasticsearch/" style="font-size: 20px;">elasticsearch</a> <a href="/tags/gson/" style="font-size: 10px;">gson</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">Half full stack developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">TedYin</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xii1s.com1.z0.glb.clouddn.com/me.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">TedYin</h1>
			</hgroup>
			
			<p class="header-subtitle">快乐比生命更重要</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/TedYin" title="github">github</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/TedYin" title="twitter">twitter</a>
			        
						<a class="mail" target="_blank" href="mailto:tedworld.time@gmail.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-irregular-shape-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/11/15/irregular-shape-1/" class="article-date">
  	<time datetime="2014-11-15T15:52:00.000Z" itemprop="datePublished">2014-11-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Irregular Shape
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>接下来几周的内容是一系列文章，来讲解Android中不规则图形的创建和使用。今天先来介绍一下圆角图片的实现。</p>
<p>有一个好消息要告诉大家，那就是在API 20中Android已经默认提供了圆角矩形的图片，RoundRectShape Drawable，但是不好的消息是大多数的人的手机版本都是20或者以上的，因此还是自己动手丰衣足食吧。<br><a id="more"></a><br>实现这种效果的方式有很多先来讨论第一种，最笨效果最差的实现。</p>
<h2 id="使用图层方式实现"><a href="#使用图层方式实现" class="headerlink" title="使用图层方式实现"></a>使用图层方式实现</h2><p>使用这种方法实现的话，我们需要使用到两张图片，一张是原图，另外一张就是与原图大小尺寸完全相同的模板图片比如下面两幅：</p>
<p><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog.jpg" alt="dog"><br><img src="http://7xii1s.com1.z0.glb.clouddn.com/mask.png" alt="mask"></p>
<blockquote>
<p>这里使用绿色的原因只是为了大家看的清楚而已。</p>
</blockquote>
<p>有了这两张图之后，我们可以加载这两张图片到内存中，然后使用<code>PoterDuffXfermode</code>类来将这两个图片合成为一张图片，就可以生成一个圆角图片的效果了。具体的代码如下：</p>
<figure class="highlight hsp"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Bitmap combineImage(Bitmap srcBitmap, Bitmap maskBitmap)&#123;</span><br><span class="line">	Bitmap resultBmp<span class="comment">;</span></span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">width</span> = srcBitmap.getWidth()&gt;maskBitmap.getWidth()?srcBitmap.getWidth():maskBitmap.getWidth()<span class="comment">;</span></span><br><span class="line">	<span class="keyword">int</span> height = srcBitmap.getHeight()&gt;maskBitmap.getHeight()?srcBitmap.getHeight():maskBitmap.getHeight()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	resultBmp = Bitmap.createBitmap(<span class="keyword">width</span>,height,Bitmap.Config.ARGB_8888)<span class="comment">;</span></span><br><span class="line">	Paint paint = new Paint()<span class="comment">;</span></span><br><span class="line">	paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode_SRC_ATOP))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	Canvas canvas = new Canvas(resultBmp)<span class="comment">;</span></span><br><span class="line">	canvas.drawBitmap(srcBitmap, <span class="number">0</span>, <span class="number">0</span>, null)<span class="comment">;</span></span><br><span class="line">    canvas.drawBitmap(maskBitmap, <span class="number">0</span>, <span class="number">0</span>, paint)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合成后的效果如下</p>
<p><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog_mask.jpg" alt="dog_mask"></p>
<p>OK，圆角矩形图片效果实现。但是这个方法实质上是最差劲的，它有如下几个缺点:</p>
<blockquote>
<ol>
<li>如果图片的形状有很多种，我们需要为每种图片都生成一张mask图片，这样效率会很低，而且工作量会加大很多。</li>
<li>适配性会变得很差，如果是圆角矩形图片，在大屏手机上拉伸回导致圆角效果失真。</li>
<li>还有个最大的问题，就是性能问题，如果图片尺寸很大，我们加载到内存中很可能出现内存溢出的情况，这样就得不偿失了。</li>
</ol>
</blockquote>
<p>因此这个方法的可用性较低，不推荐使用。但是此处为什么要介绍这个方法呢，最主要的是这个处理思路，我们可以使用上述的而方法来处理一些水印效果或者其他图片合成的效果，这样才是上述方法最好的使用方式。</p>
<p>接下来看看如何使用高效的方法创建圆角矩形。</p>
<p>##使用BitmapShader来创建圆角矩形<br>先来介绍一下使用BitmapShader的思路，其实这个很类似于我们平常使用Canvas画图形的方式，只是我们平时在画圆角矩形时填充Canvas的是纯色，这里为了得到圆角图片，我们可以使用上面的思路，将填充物由纯色改为我们要画的图片即可。具体的实现方式如下：<br><figure class="highlight armasm"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">private</span> <span class="keyword">Bitmap </span>processBitmap(<span class="keyword">Bitmap </span><span class="keyword">bitmap) </span>&#123;</span><br><span class="line">	<span class="keyword">Bitmap </span><span class="keyword">bmp;</span><br><span class="line"></span>	<span class="keyword">bmp </span>= <span class="keyword">Bitmap.createBitmap(bitmap.getWidth(), </span><span class="keyword">bitmap.getHeight(), </span><span class="keyword">Bitmap.Config.ARGB_8888);</span><br><span class="line"></span>	<span class="keyword">BitmapShader </span>shader = new <span class="keyword">BitmapShader(bitmap, </span>Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)<span class="comment">;</span></span><br><span class="line">	// 随机设置一个圆角的半径大小</span><br><span class="line">	float raidus = getResources().getDisplayMetrics().density * <span class="number">6</span> + <span class="number">0</span>.<span class="number">5</span>f<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	Canvas canvas = new Canvas(<span class="keyword">bmp);</span><br><span class="line"></span>	Paint paint = new Paint()<span class="comment">;</span></span><br><span class="line">	paint.setAntiAlias(true)<span class="comment">;</span></span><br><span class="line">	paint.setShader(shader)<span class="comment">; // 将要填充的shader交给Paint</span></span><br><span class="line"></span><br><span class="line">	RectF rect = new RectF(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">bitmap.getWidth(), </span><span class="keyword">bitmap.getHeight());</span><br><span class="line"></span>	canvas.drawRoundRect(rect, raidus, raidus, paint)<span class="comment">;// 在RectF上绘制圆角图片</span></span><br><span class="line">	return <span class="keyword">bmp;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用上述代码即可实现圆角矩形的绘制，绘制的结果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog2.png" alt="dog2"></p>
<p>同样的道理，我们可以使用上述方式，绘制出三角形，椭圆，多边形等各种各样的图片，思路和绘制圆角矩形是一样的。都是使用RectF来确定大体形状，然后使用带有BitmapShader的Paint来填充即可实现。</p>
<p>上面介绍了如何创建圆角矩形的方法，下面来介绍一下不规则图形的方法。</p>
<p>###创建聊天气泡背景效果的图片</p>
<p>创建这类图片的大体思路和上面是一致的，也是要使用<code>BitmapShader</code>这个类来进行。实现思路如下，我们可以先创建一个圆角矩形的图片，然后再在这个圆角矩形的基础之上绘制一个三角形，就可以实现带有气泡效果的图片了。现在已经知道了如何去画一个圆角矩形，那么一半工作已经算是完成了，下来要做的就是再绘制出一个三角形，然后和圆角矩形拼接在一起即可。但是现在有一个问题，<code>Canvas</code>并没有提供画三角形的方法，我们怎么办呢？在Canvas中提供了两个基本方法<code>movetTo()</code>和<code>lineTo()</code>方法，这两个方法可以让我们移动画笔画出直线，这样的话我们就可以使用这两个方法来自己动手画出三角形了（其实和Canvas封装的方法一样，只是要自己动手，显得有些麻烦）。是不是觉得很爽呢？其实这样做是有问题的，这样做智能画出一个三角形的轮廓，不会填充成一个完整的三角形。幸亏另外一个类也支持这些方法，那就是<code>Path</code>类，我们可以使用<code>Path</code>类画出一个路径，然后使用<code>Shader</code>来填充这个路径所包围的空间（路径类似于PhotoShop中的选区的概念）。有了这么一个牛逼的类，理论上讲我们是什么都可以画出来的，只要你能勾勒出那个路径，我们就能画出来。</p>
<p>好了，废话那么多下来看看如何用代码来是想上述气泡图片。</p>
<p>首先来画三角形的路径</p>
<figure class="highlight processing"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 新建一个Path类</span></span><br><span class="line">Path <span class="built_in">triangle</span> = <span class="keyword">new</span> Path();</span><br><span class="line"><span class="comment">// 下来从0点开始一次画三条线，最终首尾相连，形成一个三角形</span></span><br><span class="line"><span class="built_in">triangle</span>.moveTo(<span class="number">0</span>, TRIANGLE_OFFSET);</span><br><span class="line"><span class="built_in">triangle</span>.lineTo(TRIANGLE_WIDTH,</span><br><span class="line">    TRIANGLE_OFFSET - (TRIANGLE_HEIGHT / <span class="number">2</span>));</span><br><span class="line"><span class="built_in">triangle</span>.lineTo(TRIANGLE_WIDTH,</span><br><span class="line">    TRIANGLE_OFFSET + (TRIANGLE_HEIGHT / <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 然后close这个Path，这样一个三角形的Path就绘制完成了</span></span><br><span class="line"><span class="built_in">triangle</span>.close();</span><br></pre></td></tr></table></figure>
<p>画完三角形的Path后，下面要做的就是，将该路径所围成的图像画在圆角矩形上，然后再用Shader填充即可。<br>完整代码如下<br><figure class="highlight processing"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">float</span> RADIUS_FACTOR = <span class="number">8.0</span>f;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> TRIANGLE_WIDTH = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> TRIANGLE_HEIGHT = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> TRIANGLE_OFFSET = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Bitmap processImage(Bitmap bitmap) &#123;</span><br><span class="line">    Bitmap bmp;</span><br><span class="line"></span><br><span class="line">    bmp = Bitmap.createBitmap(bitmap.getWidth(),</span><br><span class="line">        bitmap.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">    BitmapShader <span class="built_in">shader</span> = <span class="keyword">new</span> BitmapShader(bitmap,</span><br><span class="line">        BitmapShader.TileMode.CLAMP,</span><br><span class="line">        BitmapShader.TileMode.CLAMP);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> radius = Math.<span class="built_in">min</span>(bitmap.getWidth(),</span><br><span class="line">        bitmap.getHeight()) / RADIUS_FACTOR;</span><br><span class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(bmp);</span><br><span class="line">    Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">    paint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">    paint.setShader(<span class="built_in">shader</span>);</span><br><span class="line"></span><br><span class="line">    RectF <span class="built_in">rect</span> = <span class="keyword">new</span> RectF(TRIANGLE_WIDTH, <span class="number">0</span>,</span><br><span class="line">        bitmap.getWidth(), bitmap.getHeight());</span><br><span class="line">    canvas.drawRoundRect(<span class="built_in">rect</span>, radius, radius, paint);</span><br><span class="line"></span><br><span class="line">    Path <span class="built_in">triangle</span> = <span class="keyword">new</span> Path();</span><br><span class="line">    <span class="built_in">triangle</span>.moveTo(<span class="number">0</span>, TRIANGLE_OFFSET);</span><br><span class="line">    <span class="built_in">triangle</span>.lineTo(TRIANGLE_WIDTH,</span><br><span class="line">        TRIANGLE_OFFSET - (TRIANGLE_HEIGHT / <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">triangle</span>.lineTo(TRIANGLE_WIDTH,</span><br><span class="line">        TRIANGLE_OFFSET + (TRIANGLE_HEIGHT / <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">triangle</span>.close();</span><br><span class="line">    canvas.drawPath(<span class="built_in">triangle</span>, paint);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终得到的效果图如下：</p>
<p><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog3.jpg" alt="dog3"></p>
<p>只要用好Path、Shader以及Canvas类，理论上什么图形都可以实现。</p>
<p>##终结<br>上面说了Path、Shader、Rect、Canvas等，下面我们就可以是用上述介绍的方法和类来实现一些更加复杂的图形，作为这篇文章的终结。下面我们用上述介绍的内容来绘制一张心形的图片。<br>首先说一下绘制心形图片的思路，其实这个思路和上面绘制图片的思路大同小异，最主要的思想就是使用Path画出路径，然后使用Shader来填充这个路径包围的部分。</p>
<p>大体上我们将绘制步骤分为下面4步</p>
<p>###创建好画布(Canvas)、画笔(Paint)以及要绘制图像的区域Bitmap<br><figure class="highlight mipsasm"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Bitmap </span><span class="keyword">bmp </span>= <span class="keyword">Bitmap.createBitmap(bitmap.getWidth(),</span><br><span class="line"></span>    <span class="keyword">bitmap.getHeight(), </span><span class="keyword">Bitmap.Config.ARGB_8888);</span><br><span class="line"></span><span class="keyword">BitmapShader </span><span class="keyword">shader </span>= new <span class="keyword">BitmapShader(bitmap,</span><br><span class="line"></span>    <span class="keyword">BitmapShader.TileMode.CLAMP,</span><br><span class="line"></span>    <span class="keyword">BitmapShader.TileMode.CLAMP);</span><br><span class="line"></span></span><br><span class="line">Canvas canvas = new Canvas(<span class="keyword">bmp);</span><br><span class="line"></span>Paint paint = new Paint()<span class="comment">;</span></span><br><span class="line">paint.setAntiAlias(true)<span class="comment">;</span></span><br><span class="line">paint.setShader(<span class="keyword">shader);</span></span><br></pre></td></tr></table></figure><br>因为后面要绘制不规则图形路径，有一些需要计算的地方，因此我们需要将<code>bitmap</code>的宽高记录下来。<br><figure class="highlight arduino"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> <span class="built_in">width</span> = bitmap.getWidth();</span><br><span class="line"><span class="keyword">float</span> <span class="built_in">height</span> = bitmap.getHeight();</span><br></pre></td></tr></table></figure><br>保存好宽高后，下来需要初始化Path，Region以及Matrix，这些都会在绘制心形图案时用到。<br><figure class="highlight maxima"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Path oval = <span class="built_in">new</span> Path();</span><br><span class="line">Matrix <span class="built_in">matrix</span> = <span class="built_in">new</span> Matrix();</span><br><span class="line">Region <span class="built_in">region</span> = <span class="built_in">new</span> Region();</span><br><span class="line">RectF ovalRect = <span class="built_in">new</span> RectF(<span class="built_in">width</span> / <span class="number">8</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">width</span> - (<span class="built_in">width</span> / <span class="number">8</span>), <span class="built_in">height</span>);</span><br></pre></td></tr></table></figure></p>
<p>下面来开始绘制心形图案的第二步，先绘制一个椭圆，这个椭圆的高度与我们的<code>bitmap</code>的高度一样，宽度是<code>bimap</code>的四分之三，这个宽度是来决定心形图片的宽窄的，可自行定义。<br>下面来绘制椭圆Path<br><figure class="highlight hsp"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RectF ovalRect = new RectF(<span class="keyword">width</span> / <span class="number">8</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">width</span> - (<span class="keyword">width</span> / <span class="number">8</span>), height)<span class="comment">;</span></span><br><span class="line">oval.addOval(ovalRect, Path.Direction.CW)<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>这个<code>oval</code>就是上面已经定义过的椭圆路径，在此处进行填充，这个路径渲染出来的效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog4.jpg" alt="dog4"></p>
<p>绘制出椭圆后，下来我们将其进行旋转，使用上面定义好的<code>Matrix</code>对象来完成旋转的操作：<br><figure class="highlight maxima"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">matrix</span>.postRotate(<span class="number">30</span>, <span class="built_in">width</span> / <span class="number">2</span>, <span class="built_in">height</span> / <span class="number">2</span>);</span><br><span class="line">oval.<span class="built_in">transform</span>(<span class="built_in">matrix</span>, oval);</span><br></pre></td></tr></table></figure></p>
<p>Matrix是一个很强大的类，我们可以借助它实现很多关于图片的操作。</p>
<p>旋转后的效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog5.jpg" alt="dog5"></p>
<p>有了这样的效果之后，下来要做的就是，用一个矩形路径和这个被旋转的椭圆合并出半个心形路径，然后填充这个半个心形路径就可以到半个心形图片。这里使用上面定义好的<code>Region</code>类，Region就是一个矩形类，我们用这个类和半个椭圆类结合起来就可以拼出半个心形的路径来，具体的拼接方法如下：<br><figure class="highlight hsp"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将oval椭圆的路径和矩形Region路径合并</span></span><br><span class="line">region.setPath(oval, new Region((<span class="keyword">int</span>)<span class="keyword">width</span> / <span class="number">2</span>, <span class="number">0</span>,</span><br><span class="line">    (<span class="keyword">int</span>)<span class="keyword">width</span>, (<span class="keyword">int</span>)height))<span class="comment">;</span></span><br><span class="line"><span class="comment">// 画出该路径</span></span><br><span class="line">canvas.drawPath(region.getBoundaryPath(), paint)<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>画出后的效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog6.jpg" alt="dog6"></p>
<p>好了，这样就画出了半个心形图片，重复上面的操作就可以画出另外一半的心形图片了，方法如下：</p>
<figure class="highlight maxima"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">oval.addOval(ovalRect, Path.Direction.CW);</span><br><span class="line"><span class="built_in">matrix</span>.postRotate(-<span class="number">30</span>, <span class="built_in">width</span> / <span class="number">2</span>, <span class="built_in">height</span> / <span class="number">2</span>);</span><br><span class="line">oval.<span class="built_in">transform</span>(<span class="built_in">matrix</span>, oval);</span><br><span class="line"><span class="built_in">region</span>.setPath(oval,</span><br><span class="line">    <span class="built_in">new</span> Region(<span class="number">0</span>, <span class="number">0</span>, (int)<span class="built_in">width</span> / <span class="number">2</span>, (int)<span class="built_in">height</span>));</span><br><span class="line">canvas.drawPath(<span class="built_in">region</span>.getBoundaryPath(), paint);</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog7.jpg" alt="dog7"></p>
<p>总结：只要用好Path、Shader、RectF所有的图形都可以迎刃而解，但是有一点需要注意的就是，这些操作都是比较消耗性能的操作，所以使用的时候需要注意性能问题。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/12/14/singlton/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          单例模式的使用
        
      </div>
    </a>
  
  
    <a href="/2014/10/26/http-proxy/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Http代理设置</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="irregular-shape-1" data-title="Irregular Shape" data-url="http://www.tedyin.me/2014/11/15/irregular-shape-1/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 TedYin
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>