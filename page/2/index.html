<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>TedYin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Half full stack developer.">
<meta property="og:type" content="website">
<meta property="og:title" content="TedYin's Blog">
<meta property="og:url" content="http://www.tedyin.me/page/2/index.html">
<meta property="og:site_name" content="TedYin's Blog">
<meta property="og:description" content="Half full stack developer.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TedYin's Blog">
<meta name="twitter:description" content="Half full stack developer.">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xii1s.com1.z0.glb.clouddn.com/me.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">TedYin</a></h1>
		</hgroup>

		
		<p class="header-subtitle">快乐比生命更重要！</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
						<li>A propos</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/TedYin" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">Half full stack developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">TedYin</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xii1s.com1.z0.glb.clouddn.com/me.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">TedYin</h1>
			</hgroup>
			
			<p class="header-subtitle">快乐比生命更重要！</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/TedYin" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-httpclient-urlconnection" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/12/22/httpclient-urlconnection/" class="article-date">
  	<time datetime="2014-12-22T15:40:00.000Z" itemprop="datePublished">2014-12-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/22/httpclient-urlconnection/">Android HttpURLConnection VS HttpClient</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Android中提供了两种Http操作的封装，一种使用HttpURLConnection去进行网络操作，另外一种是使用HttpClient进行网络操作的处理，这两者在Android中共存，但是官方建议使用HttpURLConnection来进行网络处理。</p>
<p>##HttpClient与HttpURLConnection在Android中的比较</p>
<p>Android中直接封装了Apache的HttpClient来作为网络操的处理类，该类是非常强大的类，比较重量级，功能和方法非常丰富，因此带来了一个问题，那就是定制性非常差，修改起来非常麻烦。相比而言HttpURLConnection要轻量许多，方法较少而且都比较简单，因此定制性更强，修改起来容易，Android团队内部也更倾向使用定制性更好的HttpURLConnection来进行网络处理。</p>
<p>但是因为在FROYO版本以及之前版本，Android对HttpURLConnection支持不好，HttpURLConnection有许多bug，所以在2.3版本之前建议使用HttpClient来进行网络操作。在FROYO以及之后的版本Android修复了HttpURLConnection的许多问题，而且在4.0之后HttpURLConnection还加入了对缓存的支持，使用下面方法可以在4.0版本中开启Http缓存:</p>
<figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void enableHttpResponseCache()&#123;</span><br><span class="line">	try&#123;</span><br><span class="line">		long httpCacheSize = 10 * 1024 * 1024; // 10 MiB</span><br><span class="line">	    File httpCacheDir = new File(getCacheDir(), &quot;http&quot;);</span><br><span class="line">	    Class.forName(&quot;android.net.http.HttpResponseCache&quot;)</span><br><span class="line">	        .getMethod(&quot;install&quot;, File.class, long.class)</span><br><span class="line">	        .invoke(null, httpCacheDir, httpCacheSize);</span><br><span class="line">	&#125;cache(Exception httpResponseCacheNotAvailable)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在客户端配置好缓存处理后，同样需要在服务端进行配置支持HttpCache，否则Cache是不会生效的。<br>在2.3以及以后的版本中，HttpURLConnection默认是支持<code>Accept-Type:gzip</code>的，只需要在服务端配置一下即可，在消息传输和获取的过程中使用压缩数据进行传输，这样会更加快速的传递数据，而且省电省流量。但是如果服务端支持gzip格式数据传输，那么在使用<code>getContentLength()</code>方法获取的就是压缩后的数据大小，这一定要注意。</p>
<p>##到底使用哪一个？<br>上面已经说的很明确了，在2.3版本之前使用HttpClient进行网络请求，在FROYO版本之后使用HttpURLConnection进行网络请求，因为2.3以前的版本市场份额已经很小很小了，所以在以后的开发中可以略去选择直接使用HttpURLConnection进行网络操作，而且Android官方也会持续改进HttpURLConnection在Android中的性能。</p>
<p>##参考<br>(参考)[<a href="http://android-developers.blogspot.tw/2011/09/androids-http-clients.html" target="_blank" rel="external">http://android-developers.blogspot.tw/2011/09/androids-http-clients.html</a>]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pager-transformer" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/12/21/pager-transformer/" class="article-date">
  	<time datetime="2014-12-21T13:07:00.000Z" itemprop="datePublished">2014-12-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/21/pager-transformer/">ViewPager PageTransformer 应用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近项目中要有个需求就是做出一个可以滑动的列表，类似于Paper效果的动画，期初设想的比较复杂，自定义监控ViewPager的OnScroll事件，然后再在onPageScrolled中根据<code>position</code>, <code>positionOffset</code>, <code>positionOffsetPixels</code>等数据就算出滑动的百分比，通过滑动的百分比来控制动画播放的百分比。这样虽然也可以实现想要的效果，但是会很复杂，有许多中间状态需要我们自己计算和保存，维护起来非常麻烦。</p>
<p>在这些复杂的实现后，在朋友的建议下使用了<code>ViewPager.PageTransformer</code>来重新实现上述效果，瞬间简单了许多，很多中间状态不许需要自己去维护，PagerTransformer会帮你去维护，并且在他提供的方法中<code>transformPage(View page, float position)</code>已经帮你计算好了滑动百分比，根本不需要你再去计算，这个简直太贴心了。其实在滑动过程中对UI修改最重要的也是最麻烦的就是去计算滑动的百分比，现在有了这个百分比，你想实现什么动画就实现什么动画，简直太爽了。</p>
<p>在使用ViewPager.PageTransformer的时候需要注意的就是他的接口方法中的postion，只要理解了它的用法，PageTransformer才算是用熟了。首先来介绍下position的用法：</p>
<ul>
<li><p>position 是一个float值，它代表了一个页面离开屏幕的百分比，以及另一个页面进入的百分比</p>
</li>
<li><p>position = 0  : page完全被展示，也就是说page处于屏幕的正中间</p>
</li>
<li>position = 1  : page完全处于屏幕的右边</li>
<li>position = -1 : page完全处于屏幕的左边</li>
</ul>
<p>如果用户拖拽position=0(当前屏幕正中央的page)的page从右往左滑动，当只滑动一半的时候，原来position = 0的page其position会由0逐渐变为 -0.5，position=1的page（屏幕右侧的page）其position会由1逐渐变为 0.5。</p>
<blockquote>
<p>注意：<br>从右往左滑 &lt;——  position为负数<br>从左往右滑 ——&gt;  position为正数</p>
</blockquote>
<p>好了理解了上面所讲的内容就可以真正的去做出漂亮的动画了，下面给一个动画实例<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static class RotatePageTransformer implements ViewPager.PageTransformer &#123;</span><br><span class="line">    private static float MIN_TRAN = 50f;</span><br><span class="line">    private static int MIN_ROTATE = 15;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transformPage(View view, float position) &#123;</span><br><span class="line">        if (position &lt;= 1) &#123;</span><br><span class="line">            float rotateFactor = MIN_ROTATE * position;</span><br><span class="line">            float tranFactor = MIN_TRAN * position;</span><br><span class="line">            if (position &lt; 0) &#123;</span><br><span class="line">                view.setTranslationY(-tranFactor);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                view.setTranslationY(tranFactor);</span><br><span class="line">            &#125;</span><br><span class="line">            view.setRotation(rotateFactor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该动画的效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/page1.png" alt="page1"><br><img src="http://7xii1s.com1.z0.glb.clouddn.com/page2.png" alt="page2"><br><img src="http://7xii1s.com1.z0.glb.clouddn.com/page3.png" alt="page3"></p>
<p>在滑动的过程总中左边和右边的会以此导向一个方向并且在Y方向上有一定位移，等到中间后图片的夹角会消失，而且会向上移动一定的距离。</p>
<p>好了，赶紧去体验一下ViewPager.PageTransformer吧。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-singlton" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/12/14/singlton/" class="article-date">
  	<time datetime="2014-12-14T15:20:00.000Z" itemprop="datePublished">2014-12-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/14/singlton/">单例模式的使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>单例模式大家应该已经很熟悉了，但是在使用单例模式的时候，我们经常会忽略一个问题，那就是多线程情况下的单例模式的使用。一般单例模式的实现会有下面两种，分别是懒汉式和饿汉式。</p>
<p>##懒汉式实现<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//懒汉式实现</span><br><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance = null;    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static newInstance()&#123;</span><br><span class="line">        if(null == instance)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething()&#123;</span><br><span class="line">        // Do something ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##饿汉式<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//饿汉式</span><br><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    public static Singleton newInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething()&#123;</span><br><span class="line">        // Do something ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>懒汉式和饿汉式的最大区别就是加载单例的时机的不同，也就是说空间和时间的问题。懒汉式是用空间换时间的典型，相反的饿汉式就是使用时间换空间的典型，上面的例子只是举了一个很简单的情况，假如这个单例对象很大非常占用内存，那么选择上述两种方式就会有很大的不同，要根据情况而确定到底使用哪一种。</p>
<p>但是不论选择上面的哪一种都会有一个问题那就是在多线程的情况下，如果是首次加载单例，就会出现生成多个单例的情况，这样如果是生成一个很大的单例对象的时候，加入这个单例对象的构造过程很复杂很耗时，那么在多线程情况下就会很容易出错，而且很耗内存，那么如何使用线程安全的单例模式呢？我们可以使用JVM自身来加载我们的单例模式，这样JVM自身在Load类的时候是线程安全的，因此我们可以利用这点写出线程安全的类。</p>
<p>##线程安全的类<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    //内部类，在装载该内部类时才会去创建单利对象</span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        public static Singleton instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    public static Singleton newInstance()&#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void doSomething()&#123;</span><br><span class="line">        //do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>利用JVM自身的特性之后，我们就再也不用担心多线程下单例模式的加载问题了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-irregular-shape-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/11/15/irregular-shape-1/" class="article-date">
  	<time datetime="2014-11-15T15:52:00.000Z" itemprop="datePublished">2014-11-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/15/irregular-shape-1/">Irregular Shape</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>接下来几周的内容是一系列文章，来讲解Android中不规则图形的创建和使用。今天先来介绍一下圆角图片的实现。</p>
<p>有一个好消息要告诉大家，那就是在API 20中Android已经默认提供了圆角矩形的图片，RoundRectShape Drawable，但是不好的消息是大多数的人的手机版本都是20或者以上的，因此还是自己动手丰衣足食吧。</p>
<p>实现这种效果的方式有很多先来讨论第一种，最笨效果最差的实现。</p>
<h2 id="使用图层方式实现"><a href="#使用图层方式实现" class="headerlink" title="使用图层方式实现"></a>使用图层方式实现</h2><p>使用这种方法实现的话，我们需要使用到两张图片，一张是原图，另外一张就是与原图大小尺寸完全相同的模板图片比如下面两幅：</p>
<p><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog.jpg" alt="dog"><br><img src="http://7xii1s.com1.z0.glb.clouddn.com/mask.png" alt="mask"></p>
<blockquote>
<p>这里使用绿色的原因只是为了大家看的清楚而已。</p>
</blockquote>
<p>有了这两张图之后，我们可以加载这两张图片到内存中，然后使用<code>PoterDuffXfermode</code>类来将这两个图片合成为一张图片，就可以生成一个圆角图片的效果了。具体的代码如下：</p>
<figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Bitmap combineImage(Bitmap srcBitmap, Bitmap maskBitmap)&#123;</span><br><span class="line">	Bitmap resultBmp;</span><br><span class="line">	int width = srcBitmap.getWidth()&gt;maskBitmap.getWidth()?srcBitmap.getWidth():maskBitmap.getWidth();</span><br><span class="line">	int height = srcBitmap.getHeight()&gt;maskBitmap.getHeight()?srcBitmap.getHeight():maskBitmap.getHeight();</span><br><span class="line"></span><br><span class="line">	resultBmp = Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);</span><br><span class="line">	Paint paint = new Paint();</span><br><span class="line">	paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode_SRC_ATOP));</span><br><span class="line"></span><br><span class="line">	Canvas canvas = new Canvas(resultBmp);</span><br><span class="line">	canvas.drawBitmap(srcBitmap, 0, 0, null);</span><br><span class="line">    canvas.drawBitmap(maskBitmap, 0, 0, paint);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合成后的效果如下</p>
<p><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog_mask.jpg" alt="dog_mask"></p>
<p>OK，圆角矩形图片效果实现。但是这个方法实质上是最差劲的，它有如下几个缺点:</p>
<blockquote>
<ol>
<li>如果图片的形状有很多种，我们需要为每种图片都生成一张mask图片，这样效率会很低，而且工作量会加大很多。</li>
<li>适配性会变得很差，如果是圆角矩形图片，在大屏手机上拉伸回导致圆角效果失真。</li>
<li>还有个最大的问题，就是性能问题，如果图片尺寸很大，我们加载到内存中很可能出现内存溢出的情况，这样就得不偿失了。</li>
</ol>
</blockquote>
<p>因此这个方法的可用性较低，不推荐使用。但是此处为什么要介绍这个方法呢，最主要的是这个处理思路，我们可以使用上述的而方法来处理一些水印效果或者其他图片合成的效果，这样才是上述方法最好的使用方式。</p>
<p>接下来看看如何使用高效的方法创建圆角矩形。</p>
<p>##使用BitmapShader来创建圆角矩形<br>先来介绍一下使用BitmapShader的思路，其实这个很类似于我们平常使用Canvas画图形的方式，只是我们平时在画圆角矩形时填充Canvas的是纯色，这里为了得到圆角图片，我们可以使用上面的思路，将填充物由纯色改为我们要画的图片即可。具体的实现方式如下：<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private Bitmap processBitmap(Bitmap bitmap) &#123;</span><br><span class="line">	Bitmap bmp;</span><br><span class="line">	bmp = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">	BitmapShader shader = new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</span><br><span class="line">	// 随机设置一个圆角的半径大小</span><br><span class="line">	float raidus = getResources().getDisplayMetrics().density * 6 + 0.5f;</span><br><span class="line"></span><br><span class="line">	Canvas canvas = new Canvas(bmp);</span><br><span class="line">	Paint paint = new Paint();</span><br><span class="line">	paint.setAntiAlias(true);</span><br><span class="line">	paint.setShader(shader); // 将要填充的shader交给Paint</span><br><span class="line"></span><br><span class="line">	RectF rect = new RectF(0, 0, bitmap.getWidth(), bitmap.getHeight());</span><br><span class="line">	canvas.drawRoundRect(rect, raidus, raidus, paint);// 在RectF上绘制圆角图片</span><br><span class="line">	return bmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用上述代码即可实现圆角矩形的绘制，绘制的结果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog2.png" alt="dog2"></p>
<p>同样的道理，我们可以使用上述方式，绘制出三角形，椭圆，多边形等各种各样的图片，思路和绘制圆角矩形是一样的。都是使用RectF来确定大体形状，然后使用带有BitmapShader的Paint来填充即可实现。</p>
<p>上面介绍了如何创建圆角矩形的方法，下面来介绍一下不规则图形的方法。</p>
<p>###创建聊天气泡背景效果的图片</p>
<p>创建这类图片的大体思路和上面是一致的，也是要使用<code>BitmapShader</code>这个类来进行。实现思路如下，我们可以先创建一个圆角矩形的图片，然后再在这个圆角矩形的基础之上绘制一个三角形，就可以实现带有气泡效果的图片了。现在已经知道了如何去画一个圆角矩形，那么一半工作已经算是完成了，下来要做的就是再绘制出一个三角形，然后和圆角矩形拼接在一起即可。但是现在有一个问题，<code>Canvas</code>并没有提供画三角形的方法，我们怎么办呢？在Canvas中提供了两个基本方法<code>movetTo()</code>和<code>lineTo()</code>方法，这两个方法可以让我们移动画笔画出直线，这样的话我们就可以使用这两个方法来自己动手画出三角形了（其实和Canvas封装的方法一样，只是要自己动手，显得有些麻烦）。是不是觉得很爽呢？其实这样做是有问题的，这样做智能画出一个三角形的轮廓，不会填充成一个完整的三角形。幸亏另外一个类也支持这些方法，那就是<code>Path</code>类，我们可以使用<code>Path</code>类画出一个路径，然后使用<code>Shader</code>来填充这个路径所包围的空间（路径类似于PhotoShop中的选区的概念）。有了这么一个牛逼的类，理论上讲我们是什么都可以画出来的，只要你能勾勒出那个路径，我们就能画出来。</p>
<p>好了，废话那么多下来看看如何用代码来是想上述气泡图片。</p>
<p>首先来画三角形的路径</p>
<figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 新建一个Path类</span><br><span class="line">Path triangle = new Path();</span><br><span class="line">// 下来从0点开始一次画三条线，最终首尾相连，形成一个三角形</span><br><span class="line">triangle.moveTo(0, TRIANGLE_OFFSET);</span><br><span class="line">triangle.lineTo(TRIANGLE_WIDTH, </span><br><span class="line">    TRIANGLE_OFFSET - (TRIANGLE_HEIGHT / 2));</span><br><span class="line">triangle.lineTo(TRIANGLE_WIDTH, </span><br><span class="line">    TRIANGLE_OFFSET + (TRIANGLE_HEIGHT / 2));</span><br><span class="line">// 然后close这个Path，这样一个三角形的Path就绘制完成了</span><br><span class="line">triangle.close();</span><br></pre></td></tr></table></figure>
<p>画完三角形的Path后，下面要做的就是，将该路径所围成的图像画在圆角矩形上，然后再用Shader填充即可。<br>完整代码如下<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static final float RADIUS_FACTOR = 8.0f;</span><br><span class="line">private static final int TRIANGLE_WIDTH = 120;</span><br><span class="line">private static final int TRIANGLE_HEIGHT = 100;</span><br><span class="line">private static final int TRIANGLE_OFFSET = 300;</span><br><span class="line"></span><br><span class="line">public Bitmap processImage(Bitmap bitmap) &#123;</span><br><span class="line">    Bitmap bmp;</span><br><span class="line"></span><br><span class="line">    bmp = Bitmap.createBitmap(bitmap.getWidth(), </span><br><span class="line">        bitmap.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">    BitmapShader shader = new BitmapShader(bitmap, </span><br><span class="line">        BitmapShader.TileMode.CLAMP, </span><br><span class="line">        BitmapShader.TileMode.CLAMP);</span><br><span class="line"></span><br><span class="line">    float radius = Math.min(bitmap.getWidth(), </span><br><span class="line">        bitmap.getHeight()) / RADIUS_FACTOR;</span><br><span class="line">    Canvas canvas = new Canvas(bmp);</span><br><span class="line">    Paint paint = new Paint();</span><br><span class="line">    paint.setAntiAlias(true);</span><br><span class="line">    paint.setShader(shader);</span><br><span class="line"></span><br><span class="line">    RectF rect = new RectF(TRIANGLE_WIDTH, 0, </span><br><span class="line">        bitmap.getWidth(), bitmap.getHeight());</span><br><span class="line">    canvas.drawRoundRect(rect, radius, radius, paint);</span><br><span class="line"></span><br><span class="line">    Path triangle = new Path();</span><br><span class="line">    triangle.moveTo(0, TRIANGLE_OFFSET);</span><br><span class="line">    triangle.lineTo(TRIANGLE_WIDTH, </span><br><span class="line">        TRIANGLE_OFFSET - (TRIANGLE_HEIGHT / 2));</span><br><span class="line">    triangle.lineTo(TRIANGLE_WIDTH, </span><br><span class="line">        TRIANGLE_OFFSET + (TRIANGLE_HEIGHT / 2));</span><br><span class="line">    triangle.close();</span><br><span class="line">    canvas.drawPath(triangle, paint);</span><br><span class="line"></span><br><span class="line">    return bmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终得到的效果图如下：</p>
<p><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog3.jpg" alt="dog3"></p>
<p>只要用好Path、Shader以及Canvas类，理论上什么图形都可以实现。</p>
<p>##终结<br>上面说了Path、Shader、Rect、Canvas等，下面我们就可以是用上述介绍的方法和类来实现一些更加复杂的图形，作为这篇文章的终结。下面我们用上述介绍的内容来绘制一张心形的图片。<br>首先说一下绘制心形图片的思路，其实这个思路和上面绘制图片的思路大同小异，最主要的思想就是使用Path画出路径，然后使用Shader来填充这个路径包围的部分。</p>
<p>大体上我们将绘制步骤分为下面4步</p>
<p>###创建好画布(Canvas)、画笔(Paint)以及要绘制图像的区域Bitmap<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bmp = Bitmap.createBitmap(bitmap.getWidth(), </span><br><span class="line">    bitmap.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">BitmapShader shader = new BitmapShader(bitmap, </span><br><span class="line">    BitmapShader.TileMode.CLAMP, </span><br><span class="line">    BitmapShader.TileMode.CLAMP);</span><br><span class="line"> </span><br><span class="line">Canvas canvas = new Canvas(bmp);</span><br><span class="line">Paint paint = new Paint();</span><br><span class="line">paint.setAntiAlias(true);</span><br><span class="line">paint.setShader(shader);</span><br></pre></td></tr></table></figure><br>因为后面要绘制不规则图形路径，有一些需要计算的地方，因此我们需要将<code>bitmap</code>的宽高记录下来。<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float width = bitmap.getWidth();</span><br><span class="line">float height = bitmap.getHeight();</span><br></pre></td></tr></table></figure><br>保存好宽高后，下来需要初始化Path，Region以及Matrix，这些都会在绘制心形图案时用到。<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Path oval = new Path();</span><br><span class="line">Matrix matrix = new Matrix();</span><br><span class="line">Region region = new Region();</span><br><span class="line">RectF ovalRect = new RectF(width / 8, 0, </span><br><span class="line">    width - (width / 8), height);</span><br></pre></td></tr></table></figure></p>
<p>下面来开始绘制心形图案的第二步，先绘制一个椭圆，这个椭圆的高度与我们的<code>bitmap</code>的高度一样，宽度是<code>bimap</code>的四分之三，这个宽度是来决定心形图片的宽窄的，可自行定义。<br>下面来绘制椭圆Path<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RectF ovalRect = new RectF(width / 8, 0, </span><br><span class="line">    width - (width / 8), height);</span><br><span class="line">oval.addOval(ovalRect, Path.Direction.CW);</span><br></pre></td></tr></table></figure><br>这个<code>oval</code>就是上面已经定义过的椭圆路径，在此处进行填充，这个路径渲染出来的效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog4.jpg" alt="dog4"></p>
<p>绘制出椭圆后，下来我们将其进行旋转，使用上面定义好的<code>Matrix</code>对象来完成旋转的操作：<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix.postRotate(30, width / 2, height / 2);</span><br><span class="line">oval.transform(matrix, oval);</span><br></pre></td></tr></table></figure></p>
<p>Matrix是一个很强大的类，我们可以借助它实现很多关于图片的操作。</p>
<p>旋转后的效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog5.jpg" alt="dog5"></p>
<p>有了这样的效果之后，下来要做的就是，用一个矩形路径和这个被旋转的椭圆合并出半个心形路径，然后填充这个半个心形路径就可以到半个心形图片。这里使用上面定义好的<code>Region</code>类，Region就是一个矩形类，我们用这个类和半个椭圆类结合起来就可以拼出半个心形的路径来，具体的拼接方法如下：<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 将oval椭圆的路径和矩形Region路径合并</span><br><span class="line">region.setPath(oval, new Region((int)width / 2, 0, </span><br><span class="line">    (int)width, (int)height));</span><br><span class="line">// 画出该路径</span><br><span class="line">canvas.drawPath(region.getBoundaryPath(), paint);</span><br></pre></td></tr></table></figure><br>画出后的效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog6.jpg" alt="dog6"></p>
<p>好了，这样就画出了半个心形图片，重复上面的操作就可以画出另外一半的心形图片了，方法如下：</p>
<figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">oval.addOval(ovalRect, Path.Direction.CW);</span><br><span class="line">matrix.postRotate(-30, width / 2, height / 2);</span><br><span class="line">oval.transform(matrix, oval);</span><br><span class="line">region.setPath(oval, </span><br><span class="line">    new Region(0, 0, (int)width / 2, (int)height));</span><br><span class="line">canvas.drawPath(region.getBoundaryPath(), paint);</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="http://7xii1s.com1.z0.glb.clouddn.com/dog7.jpg" alt="dog7"></p>
<p>总结：只要用好Path、Shader、RectF所有的图形都可以迎刃而解，但是有一点需要注意的就是，这些操作都是比较消耗性能的操作，所以使用的时候需要注意性能问题。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-http-proxy" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/10/26/http-proxy/" class="article-date">
  	<time datetime="2014-10-26T13:10:00.000Z" itemprop="datePublished">2014-10-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/26/http-proxy/">Http代理设置</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android应用程序访问互联网时，如果处于WIFI或者CMNET、UNINET或者3GNET，CTNET等接入方式时，无需设置代理即可顺利的访问网络，但是如果处于WAP环境下，那么就需要首先设置代理，之后才能访问互联网。跟设置超时一样，设置代理同样有HttpClient和HttpURLConnection两种方式：</p>
<p>##HttpClient方式<br><figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = new DefaultHttpClient();</span><br><span class="line">String host = Proxy.getDefaultHost(); //默认代理服务器地址</span><br><span class="line">int port = Proxy.getDefaultPort(); //默认代理服务器端口号</span><br><span class="line">HttpHost httpHost = new HttpHost(host, port);</span><br><span class="line">HttpParams params = httpClient.getParams();</span><br><span class="line">params.setParameter(ConnRouteParams.DEFAULT_PROXY, httpHost); //设置默认代理</span><br></pre></td></tr></table></figure></p>
<p>##HttpURLConnection方式</p>
<figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String host = android.net.Proxy.getDefaultHost(); // 默认代理服务器地址</span><br><span class="line">int port = android.net.Proxy.getDefaultPort(); // 默认代理服务器端口号</span><br><span class="line">SocketAddress socketAddr = new InetSocketAddress(host, port);</span><br><span class="line">// 构造代理对象</span><br><span class="line">java.net.Proxy proxy = new java.net.Proxy(java.net.Proxy.Type.HTTP, socketAddr);</span><br><span class="line">try &#123;</span><br><span class="line">  URL url = new URL(&quot;www.baidu.com&quot;);</span><br><span class="line">  // 设置代理</span><br><span class="line">  HttpURLConnection conn = (HttpURLConnection) url.openConnection(proxy);</span><br><span class="line">&#125; catch (MalformedURLException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##参考<br><a href="http://blog.csdn.net/ace1985/article/details/7844159" target="_blank" rel="external">Android通过WAP方式联网</a> </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ssh-use" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/10/19/ssh-use/" class="article-date">
  	<time datetime="2014-10-19T08:02:00.000Z" itemprop="datePublished">2014-10-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/19/ssh-use/">SSH的原理与使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是SSH"><a href="#什么是SSH" class="headerlink" title="什么是SSH"></a>什么是SSH</h2><p>SSH是Secure Shell的简称，是由IEFT网络工作组制定，用来为远程登录等网路服务提供一种安全的信息传输协议。最初是用于Unix平台，现在各个平台上都可以使用SSH协议程序进行信息传输。SSH只是一种协议，针对这种协议的实现有很多个版本，有商业化闭源的实现也有开源的实现，OpenSSH就是著名的开源SSH实现。</p>
<h2 id="SSH登录远程主机的过程"><a href="#SSH登录远程主机的过程" class="headerlink" title="SSH登录远程主机的过程"></a>SSH登录远程主机的过程</h2><p>假设有客户端要远程登录服务器，使用SSH登录的过程如下：</p>
<ol>
<li>客户端向服务端发起连接请求，服务端收到请求后，返回给客户端一个公钥。</li>
<li>客户端使用该公钥加密用户明和登录密码，然后将加密后的数据传递给服务端。</li>
<li>服务端收到用户传递过来的加密数据后，使用自己的私钥解密，检查用户是否为合法用户。</li>
<li>如果用户合法，则简历连接，否则拒绝连接。</li>
</ol>
<p>在上述登录过程中，如果用户是第一次登录远程主机，那么在用户收到远程主机的公钥后，本地终端就会提示用户注意远程主机是否为真实的目标主机，提示信息一般如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;host (12.18.429.21)&apos; can&apos;t be established.</span><br><span class="line">　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">　　Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>
<p>在用户根据IP地址和服务端指纹信息确定之后，SSH程序会将该主机信息保存在本地，当下次再登录该主机时，将会直接体使用户输入密码来登录，将不再会提示用户所登录的主机信息。</p>
<p>###中间人攻击</p>
<p>在用户首次登录的时之所以提示用户登录信息，是因为在逻辑上SSH有个漏洞，假如用户在一个开放网络中，在服务端和客户端之间存在一个第三方的主机(中间人主机)，而且用户登录时被中间人主机拦截，并向客户端返回了自己伪造的公钥，但是用户并未检查所登录的主机是否为目标主机，此时使用伪造的公钥将用户数据加密后传给中间人主机，这样中间人主机就可以拿到用户的登录信息，这就会导致严重的安全事故。因此在为了避免中间人攻击，我们需要在首次登录时，检查目标主机的信息是否为我们所要登录的目标主机，确认之后在进行登录操作。</p>
<p>###使用公钥登录<br>为了更好的避免中间人攻击，并且方便我们使用SSH登录，我们可以使用SSH提供的公钥登录，我们可以在本地使用<code>ssh-keygen</code>命令生成一组公钥和私钥默认为(id_rsa.pub和id_rsa)，然后我们将公钥存储在我们要登录的服务端。当使用公钥登录时，客户端发起连接，服务端会随机发送一串字符串，客户端使用私钥加密后再回传给服务端，服务端收到用户回传的加密数据和，使用先前用户存储在服务端的公钥进行解密，然后检查数据是否正确，如果正确则建立连接，否则拒绝连接，并返回拒绝原因。</p>
<p>使用公钥登录后，用户就不必再去每次都输入用户名和密码，而是直接建立连接，也很好的避免了中间人攻击的问题，是一个比较好的解决办法，只是相比直接用口令登录要麻烦一点，不过一劳永逸，刚开始麻烦后面就简单多了。</p>
<p>##SSH登录使用</p>
<p>使用SSH登录非常简单，命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//ssh [username]@[server ip/domain]</span><br><span class="line"></span><br><span class="line">ssh user@server.com</span><br></pre></td></tr></table></figure>
<p>指定端口登录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//ssh -P port [username]@[server ip/domain]</span><br><span class="line"></span><br><span class="line">ssh -P 2222 user@server.com</span><br></pre></td></tr></table></figure>
<p>SSH的默认端口号是22，可以通过<code>-P</code>参数来指定端口号。</p>
<p>SSH登录时的默认端口是22，如果服务端根据自身需要，要求客户端使用别的端口(例如2222)进行登录时，我们可以在客户端使用-P参数来指定登录端口</p>
<p>##参考<br><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="external">ssh原理以及使用</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-log4j" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/10/12/log4j/" class="article-date">
  	<time datetime="2014-10-12T13:37:00.000Z" itemprop="datePublished">2014-10-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/12/log4j/">Log4J介绍</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##Log4J是什么？</p>
<p>Log4J是Apache基金会下一个开源的日志管理项目，可以高度自定义日志的收集过程，和收集粒度，以及收集后日志的输出位置，可以输出到控制台，文件，数据库，甚至是远程服务器，这些操作仅仅只需要通过Log4J的配置文件进行定义后便可实现，是一个非常而且强大的日志收集库。除此之外，Log4J提供多语言兼容，可以在Java，Python，.Net等语言环境下的服务器中使用，可以对服务集群的日志进行统一管理。</p>
<p>##Log4J学习</p>
<p>Log4J三大组件：</p>
<ol>
<li>Logger（记录器）：只管记录日志（根据日志级别记录），不管日志存储在什么地方。</li>
<li>Appender（存放器）：将Logger记录的日志，存放到配置文件中所指向的地方，只处理日志的存放过程。</li>
<li>Layout（布局）：将日志进行格式化后再输出，也就是说他是用来让日志看这更顺眼的。当然如何算顺眼，由你在配置文件中设定。</li>
</ol>
<blockquote>
<p>一个Logger可以有多个Appender，可以同时输出到多个设备上，每一个Appender都有一个Layout来格式化输出内容。</p>
</blockquote>
<p>###Logger 组件<br>有一个超类，log4j.rootLogger这个超类永远存在，可以使用Logger类中的getRootLogger()方法来获得这个对象的引用。</p>
<p>Logger组件的继承关系：</p>
<ol>
<li>如果子类Logger没有定义日志级别，那么它将继承父类的日志级别。</li>
<li>如果把子类Logger的组件的additivity设置为false(默认为true)，那子类将不会继承父类的Appender，否则将继承父类所有的Appender。</li>
</ol>
<p>###Appender 组件<br>Appender用来决定日志要输出到什么地方，支持一下目的地：</p>
<ol>
<li>控制台Console</li>
<li>文件File</li>
<li>GUI组件</li>
<li>套接口服务器（Remote Socket Server）</li>
<li>NT的事件记录器</li>
<li>UNIX守护进程（输出到某个进程中去）(待验证)</li>
</ol>
<p>###Layout 组件<br>Layout组件决定日志的输出格式,有如下几类：</p>
<ol>
<li>org.apache.log4j.HTMLLayout     以Html格式输出日志</li>
<li>org.apache.log4j.PatternLayout  以自定义Pattern的模式输出日志</li>
<li>org.apache.log4j.SimpleLayout   包含日志信息的级别和，日志字符串</li>
<li>org.apache.log4j.TTCCLayout     包含日志产生的线程，时间，类别等详细信息</li>
</ol>
<p>##日志级别<br>日志级别分为5种：</p>
<ul>
<li>fatal      严重错误，会导致系统崩溃</li>
<li>error     虽然出错，但是系统依然可以运行  </li>
<li>warn     警告，系统此处会有发生潜在错误的可能性</li>
<li>info       一般的运行时信息</li>
<li>debug  调试信息，粒度很细</li>
</ul>
<p>除了上述5中级别外，还有两种特殊级别的日志分类：</p>
<ul>
<li>off        关闭日志，级别最高</li>
<li>all         打开日志，级别最低</li>
</ul>
<p>以上日志的级别高低排序如下：<br>off &gt; fatal &gt; error &gt; warn &gt; info &gt; debug &gt; all<br>当日配置的志级别为info时所有的Debug日志将不会输出。</p>
<p>Log4J建议使用上述中的4种分别是：error、warn、info、debug</p>
<p>##Log4J 应用<br>对于应用，无非就是配置和使用，先来看看如何在程序中配置Log4J</p>
<p>###Log4J的配置<br>Log4J支持XML配置和properties文件两种方式进行配置，此处介绍后一种。</p>
<p>####set Logger<br>log4j.rootLogger=INFO,infoLog,file</p>
<p>####infoLog logger<br>log4j.appender.infoLog=org.apache.log4j.ConsoleAppender // 配置Appender<br>log4j.appender.infoLog.layout=org.apache.log4j.PatternLayout // 配置Layout<br>log4j.appender.infoLog.layout.ConversionPattern=%d-[TS] %p %t %c - %m%n </p>
<p>####file logger<br>log4j.appender.file=org.apache.log4j.FileAppender // 定义Appender<br>log4j.appender.file.File=log.txt<br>log4j.appender.file.layout=org.apache.log4j.PatternLayout // 定义Layout<br>log4j.appender.file.layout.ConversionPattern=%d-[TS] %p %t %c - %m%n// 自定义Layout格式</p>
<p>####Error log<br>log4j.errorLog=ERROR, errorLog</p>
<p>####errorLog logger<br>log4j.appender.errorLog=org.apache.log4j.FileAppender<br>log4j.appender.errorLog.File=errorLog.txt<br>log4j.appender.errorLog.layout=org.apache.log4j.PatternLayout<br>log4j.appender.errorLog.layout.ConversionPattern=%d-[TS] %p %t %c - %m%n</p>
<p><em>详细的使用请参考Log4J的<a href="http://logging.apache.org/log4j/1.2/apidocs/" target="_blank" rel="external">API</a></em></p>
<p>##Log4J在程序中的应用</p>
<ol>
<li>先将log4j-xxx.jar导入工程中。</li>
<li>新建log4j.properties配置文件，并加入配置。</li>
<li>在程序中使用Log4J的API。</li>
</ol>
<p>##参考：<br><a href="http://blog.csdn.net/lyc557/article/details/3964459" target="_blank" rel="external">日志级别</a><br><a href="http://www.iteye.com/topic/158409" target="_blank" rel="external">Log4J的使用</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-group-resource" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/28/group-resource/" class="article-date">
  	<time datetime="2014-09-28T11:08:00.000Z" itemprop="datePublished">2014-09-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/28/group-resource/">Providing Resources</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在的Android系统运行在各种尺寸的机器上，对于开发者，我们需要让我们的应用适应这些大大小小的屏幕确实比较困难，但是Android给我们提供了一套简单而且方便的机制来帮助我们完成适配，首先我们来看看资源文件的组织方式。</p>
<p>##组织资源文件<br>众所周知资源文件都存放在<code>res/</code>目录下的各个文件夹中，这些文件夹都有着各自不同的意义。</p>
<ul>
<li><code>animator/</code> 存放属性动画(property animation)</li>
<li><code>anim/</code> 存放Tween动画</li>
<li><code>color/</code> 存放颜色状态的xml文件（即：按钮按下什么颜色，正常什么颜色之类的selector文件）</li>
<li><code>drawable/</code> 存放图片文件(.png/.9.png/.gif/.jpg/.xml)xml可以为帧动画的animation-list文件，也可以为shape类型文件</li>
<li><code>layout/</code> 存放布局文件</li>
<li><code>menu/</code> 存放Options Menu 或者 Context Menu 或者Sub Menu</li>
<li><code>raw/</code> 存放多媒体文件，该文件夹下的文件在生成APK时不会被压缩成二进制，会保存其原有的格式。这点类似于<code>asset/</code>文件夹。</li>
<li><code>values/</code> 该文件夹下存放了App中核心的数值文件，包括<code>strings.xml</code>,<code>style.xml</code>,<code>array.xml</code>,<code>integers.xml</code>,<code>attrs.xml</code>,<code>colors.xml</code>,<code>dimens.xml</code>等APP中需要的颜色样式，距离数值字符串等文件，具体的样式类型可参考具体的Resource部分。</li>
<li><code>xml/</code>该文件夹下存放Runtime中能获取的或需要的xml类型的各种文件，可以通过<code>Resources.getXML(int resId)</code>来获取该文件的解析器<code>XmlResourceParser</code>对象。</li>
</ul>
<blockquote>
<p><code>asset/</code>与<code>res/raw</code>下的文件在生成APK包时，都不会被压缩。他们的区别是</p>
<ul>
<li><code>asset/</code>文件夹下的文件不会在R.java文件中生成映射，因此不能通过Id来引用，但是<code>res/raw/</code>下的文件可以在R.java下生成映射，可以通过Id进行索引。</li>
<li><code>asset/</code>文件夹下可以再继续添加文件夹，但是<code>res/raw/</code>下不许再出现子文件夹。</li>
<li><code>asset/</code>下的文件或文件夹通过<code>AssetManager</code>类来访问，<code>res/raw/</code>文件夹下的文件通过<code>Resources.openRawResource(int resId)</code>来访问。</li>
</ul>
</blockquote>
<p>##适配不同的屏幕</p>
<p>上述说明了资源文件的基本结构，上述的结构中是Android资源文件组织的最基本结构，如果要适配不同的屏幕，就需要在上述基础上使用更复杂的文件结构来适配不同的布局。</p>
<ol>
<li>在<code>res/</code>下创建<code>&lt;resources_name&gt;-&lt;config_qualifier&gt;</code>这种格式的文件夹，<code>&lt;config_qualifier&gt;</code>的属性可以添加多个，中间使用<code>-</code>隔开即可,但是要注意分类的顺序，大类属性在前，小类属性在后即可(大类属性中包含了小类属性)，前面的属性包含后面的属性举例如下:</li>
</ol>
<figure class="highlight plain"><figcaption><span>lang: xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">res/</span><br><span class="line">    drawable/   </span><br><span class="line">        icon.png</span><br><span class="line">        background.png    </span><br><span class="line">    drawable-hdpi/  </span><br><span class="line">        icon.png</span><br><span class="line">        background.png  </span><br><span class="line">    drawable-hdpi-landscape/  </span><br><span class="line">    	icon.png</span><br><span class="line">    	background.png</span><br></pre></td></tr></table></figure>
<p>上述<code>drawable</code>就是规定格式中的<code>&lt;resources_name&gt;</code>，<code>hdpi</code>就是规定格式中的<code>&lt;config_qualifier&gt;</code>。只要按照规定格式<code>&lt;config_qualifier&gt;</code>部分的内容可以自定义，但是不推荐这样做。</p>
<blockquote>
<p>使用了所有的<code>&lt;config_qualifier&gt;</code>的资源文件夹命名，排列的顺序是按照优先级排列的，结果为：<br>values-mcc310-en-sw320dp-w720dp-h720dp-large-long-port-car-night-ldpi-notouch-keysexposed-nokeys-navexposed-nonav-v7<br>具体的解释下:<br>values-mcc310(sim卡运营商)-en(语言)-sw320dp(屏幕最小宽度)-w720dp(屏幕最佳宽度)-h720dp(屏幕最佳高度)-large(屏幕尺寸)-long(屏幕长短边模式)-port(当前屏幕横竖屏显示模式)-car(dock模式)-night(白天或夜晚)-ldpi(屏幕最佳dpi)-notouch(触摸屏模类型)-keysexposed(键盘类型)-nokey(硬按键类型)-navexposed(方向键是否可用)-nonav(方向键类型)-v7(android系统版本API level 7)</p>
</blockquote>
<ol>
<li>多套资源的命名必须和默认的(drawable、layout等)相同。具体的文件命名和组织结构可参考<a href="http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources" target="_blank" rel="external">不同资源的命名和组织</a></li>
</ol>
<p>##为多个尺寸屏幕提供最好的适配<br>为了适配大多数的机型，在组织App的资源文件时必须提供一套默认的资源数据，这样做的目的就是在无法找到合适的<code>&lt;config_qualifier&gt;</code>数据的时候可以使用默认的资源，而不至于找不到资源文件而崩溃，在API level 4以后，drawable资源可以不需要指定默认的资源文件，因为Android会根据屏幕的信息自己找到合适的图片资源并进行必要的缩放，但是此处还是推荐大家指定所有的默认资源！</p>
<p>##Android是如何找到最合适的资源文件的</p>
<p>如果提供了多套资源文件时，Android在运行时会根据设备的属性找到合适的资源文件来使用。Android查找合适的资源文件的过程是一个循环排除的过程，它会读取一堆设备的属性，然后根据这些属性循环过滤所有的资源文件，最后只剩下唯一的一个即为最优的资源文件。对于图片资源的查找，如果找不到最合适的，它会找接近最优解的资源，如果有两类图片资源都是次优解，一类是低像素的图片，一类是高像素的图片，Android会采用将高像素的图像缩小的策略来适配，而不会采用将低像素的图片放大的操作。因此理论上只要提供一套<code>xxxhdpi</code>的图片即可。但是一定要注意一点，选取图片像素高的进行放大，并不是说我们只用一套<code>xlarge</code>的图像就可以适配所以机型了。因为Android在排除资源的时候，如果当前的机型的屏幕类型是Normal Screen，而资源文件都是<code>xlarge</code>类型的没有Normal类型的，那么系统也不会使用这套资源，这样会导致程序崩溃，提示资源不可用或者无法找到等错误，因此在提供多套资源的时候尽量不要省略，一定要提供给默认的资源。</p>
<p>循环排除算法的流程图：</p>
<p><img src="http://7xii1s.com1.z0.glb.clouddn.com/201409182210.png" alt="循环排除流程图"></p>
<p>##参考<br><a href="http://www.cnblogs.com/leizhenzi/archive/2011/10/18/2216428.html" target="_blank" rel="external">raw和asset的区别</a><br><a href="http://developer.android.com/guide/topics/resources/providing-resources.html" target="_blank" rel="external">资源文件的组织</a><br><a href="http://ivan-ru.iteye.com/blog/1711414" target="_blank" rel="external">文件夹属性的使用</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-handling-congfig-change" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/21/handling-congfig-change/" class="article-date">
  	<time datetime="2014-09-21T12:22:00.000Z" itemprop="datePublished">2014-09-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/21/handling-congfig-change/">Handling Runtime Changes</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##Runtime Changes 是什么<br>在Android运行期间，当设备的一些属性改变时，为了更好的使得App适应设备的改变，Android会主动destory当前的Activity，并且重新创建并启动它，以适应设备属性的改变。这样做的目的是为了更好的方便我们处理这些Change。</p>
<p>##常见的改变<br>常见的当以下情况其中之一发生时都会引起Activity被Destory并且重新调用onCreate去创建启动</p>
<ul>
<li>当屏幕方向改变时</li>
<li>当键盘隐藏或者显示时</li>
<li>当系统语言改变时</li>
</ul>
<p>以上是常见的几个会引起，Activity被Destory掉，并且立即被重新创建的操作，其他的操作可以参考<a href="http://developer.android.com/reference/android/content/res/Configuration.html" target="_blank" rel="external">开发文档</a></p>
<p>##处理这些改变<br>处理这些改变有两类操作</p>
<ul>
<li>在Configuration改变时保存当前的上下文状态对象</li>
<li>自己手动处理Configuration改变导致的页面重启</li>
</ul>
<blockquote>
<p>这里以屏幕方向改变为例</p>
</blockquote>
<p>###保存当前状态对象</p>
<p>如果在屏幕改变方向时重启当前的Activity时需要很多的数据，并且消耗很多时间的话，我们可以在Activity被Destory之前保存这些需要重新加载的数据，然后等到Activity启动后直接加载这些数据就可以了。那么Activity都被销毁了，这些数据怎么存储呢？当然有办法！但不是使用Bundle，因为它没有办法存储大量的数据，它的设计也不是被用来存储大量数据的，因为它内部的数据都是序列化的，如果将数据存储到Bundle中需要先序列化，然后取数据的时候再反序列化，这样一来一回对于有很多数据时开销就会很大，得不偿失。<br>     我们可以使用Fragment来存储这些数据，当系统因为屏幕方向的改变，销毁了你的Activity时，用来保存Activity状态的对象不会被销毁，当Activity再次被重启时可以通过FragmentManager来获取这个Fragment，并从中得到Activity存入的状态对象。具体实现方法如下：</p>
<ol>
<li>创建一个用来存储Activity状态对象的Fragment，DataFragment</li>
<li>在onCreate方法中调用 setRetainInstance(true)方法</li>
<li>把这个Fragment添加到FragmentManager中，确保当Activity再次启动时还可以得到该Fragment的引用。</li>
</ol>
<figure class="highlight plain"><figcaption><span>lang: Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DataFragment extends Framgent&#123;</span><br><span class="line">     private MyDataObject mData;</span><br><span class="line">     public void onCreate(Bundle savedInstanceState)&#123;</span><br><span class="line">          // retain this fragment </span><br><span class="line">          setRetainInstance(true);</span><br><span class="line">     &#125;     </span><br><span class="line">     </span><br><span class="line">     public MyDataObject getData()&#123;</span><br><span class="line">          return mData;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public void setData(MyDataObject data)&#123;</span><br><span class="line">          this.data = mData;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>注意：在Fragment中保存数据时，禁止保存和Activity绑定的数据，比如View，Adapter或Drawable等。因为Activity会被销毁后再重新启动，当重启后View等对象中引用的Activity已经失效，会引起错误导致程序崩溃。</li>
</ul>
<ul>
<li>在setRetainInstance(boolean)方法设置为true的作用就是防止当Fragment所在的Activity被销毁的时候，Fragment不被销毁，设置为true后，Fragment的生命周期会有所改变，<code>onDestory()</code>方法不会被调用，但是<code>onDeteach()</code>方法会被调用，当Activity再次启动后，<code>onCreate()</code>方法不会被调用，<code>onAttach()</code>方法会被调用，<code>onActivity()</code>方法也会被调用。（就是跳过了Fragment的创建和销毁过程）</li>
</ul>
</blockquote>
<p>当Activity重启之后，可通过FragmentManager获取，保存数据的Fragment，然后从Fragment中恢复保存的数据，代码如下:</p>
<figure class="highlight plain"><figcaption><span>lang: Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class MyActivity extends Activity&#123;</span><br><span class="line"></span><br><span class="line">     private MyDataObject mData;</span><br><span class="line">     private DataFragment dataFragment;</span><br><span class="line">     @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line"></span><br><span class="line">        // find the retained fragment on activity restarts</span><br><span class="line">        FragmentManager fm = getFragmentManager();</span><br><span class="line">        dataFragment = (DataFragment) fm.findFragmentByTag(“data”);</span><br><span class="line"></span><br><span class="line">        // create the fragment and data the first time</span><br><span class="line">        if (dataFragment == null) &#123;</span><br><span class="line">            // add the fragment</span><br><span class="line">            dataFragment = new DataFragment();</span><br><span class="line">            fm.beginTransaction().add(dataFragment, “data”).commit();</span><br><span class="line">            // load the data from the web</span><br><span class="line">            dataFragment.setData(loadMyData());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // the data is available in dataFragment.getData()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        // store the data in the fragment</span><br><span class="line">        dataFragment.setData(collectMyLoadedData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以在Activity重启之后获取保存的状态对象了。</p>
<blockquote>
<p>这里是将Fragment当容器来使用，利用了它的特性，存储Activity的状态对象。而且在获取时，由FragmentManager来管理Fragment的状态，这样既方便又安全。</p>
</blockquote>
<p>###自定义处理Configuration的变化<br>如果在Configuration变化时没有资源文件的更新(横竖屏不同布局)，或者因为性能的要求，不需要重启当前Activity的话，我们可以通过自定义处理Configuration的变化来代替系统的默认处理(重启Activity)。使用<code>&lt;activity&gt;</code>标签下的<code>&lt;android:configChanges&gt;</code>属性来指定需要自定义处理的属性变换。代码如下:</p>
<figure class="highlight plain"><figcaption><span>lang: xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;activity android:name=&quot;.MyActivity&quot;</span><br><span class="line">    android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</span><br><span class="line">    android:label=&quot;@string/app_name&quot;]]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当在<code>&lt;activity&gt;</code>中配置好之后，我们可以通过重写<code>onConfigurationChanged(Configuration)</code>方法来自定义处理Configuration的属性变化。</p>
<figure class="highlight plain"><figcaption><span>lang: Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Overried</span><br><span class="line">public void onConfigurationChanged(Configuration newConfig)&#123;</span><br><span class="line">     super.onConfigurationChanged(newConfig);</span><br><span class="line"></span><br><span class="line">    // Checks the orientation of the screen</span><br><span class="line">    if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line">        Toast.makeText(this, &quot;landscape&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125; else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT)&#123;</span><br><span class="line">        Toast.makeText(this, &quot;portrait&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在3.2版本 API level 13之后，<code>screen size</code>属性的改变也会引起Activity的销毁并重启。而且congfigChanges的属性都是Integer的，如果是自定义处理属性改变，那么在属性改变后所需要重新加载的数据都要重新设置一遍。比如，某个图片横屏和竖屏是不同的，那么就需要在onConfigurationChanged()方法中重新设置该图片的资源。</p>
</blockquote>
<p>##参考<br><a href="http://developer.android.com/guide/topics/resources/runtime-changes.html" target="_blank" rel="external">Handling Runtime Changes</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-learn-gson" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/14/learn-gson/" class="article-date">
  	<time datetime="2014-09-14T14:15:00.000Z" itemprop="datePublished">2014-09-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/14/learn-gson/">Gson的使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Gson概述"><a href="#Gson概述" class="headerlink" title="Gson概述"></a>Gson概述</h2><p>Gson是Google内部为了使用的一个将Java对象序列化为JSON的Java类库，从2008年5月Google开源此项目后被广泛使用。类似的项目还有<a href="https://github.com/alibaba/fastjson/wiki" target="_blank" rel="external">FastJson</a>、<a href="http://jackson.codehaus.org" target="_blank" rel="external">JackSon</a>等。</p>
<h2 id="Gson使用"><a href="#Gson使用" class="headerlink" title="Gson使用"></a>Gson使用</h2><p>###Gson对基本数据类型的解析</p>
<figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Gson gson = new Gson();</span><br><span class="line">toJson：</span><br><span class="line">gson.toJson(1) --&gt; 1</span><br><span class="line">gson.toJson(&quot;abc&quot;) --&gt; abc</span><br><span class="line">gson.toJson(new Long(10)) --&gt;10</span><br><span class="line">gson.toJson(new int[]&#123;1,2,3&#125;) --&gt;[1,2,3]</span><br><span class="line">gson.toJson(new String[]&#123;&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;&#125;) --&gt; [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fromJson：</span><br><span class="line">int one = gson.fromJson(&quot;1&quot;,int.class);</span><br><span class="line">int[] ints = gson.fromJson(&quot;[1,2,3]&quot;,int[].class);</span><br><span class="line">Integer integer = gson.fromJson(&quot;1&quot;,Integer.class);</span><br><span class="line">Boolean boolean = gson.fromJson(&quot;false&quot;,Boolean.calss);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>###Gson解析对象</p>
<figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String playerJson = gson.toJson(new Player());</span><br><span class="line">Player player = gson.fromJson(playerJson,Player.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>###Gson对集合类的解析</p>
<figure class="highlight plain"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">toJson:</span><br><span class="line">Collection&lt;Integer&gt; collection = 新建一个集合类，并存入1,2,3,4</span><br><span class="line">gson.toJson(collection) --&gt; [1,2,3,4]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fromJson:</span><br><span class="line">Type type = new TypeToken&lt;Collection&lt;Integer&gt;&gt;()&#123;&#125;.getType();//匿名内部类</span><br><span class="line"></span><br><span class="line">Collection&lt;Integer&gt; collection = gson.fromJson(json,type);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用Gson的几点注意事项"><a href="#使用Gson的几点注意事项" class="headerlink" title="使用Gson的几点注意事项"></a>使用Gson的几点注意事项</h2><blockquote>
<p>eg:使用Gson解析A.class</p>
</blockquote>
<ol>
<li>如果A含有内部类且不是static的，则在解析是会忽略该内部类。</li>
<li>Gson会自动加载A.class中所引用的类，并对其进行解析。(类似于克隆)</li>
<li>如果A中含有transient修饰的变量时，Gson会忽略该变量。</li>
<li>如果A中含有组合类型，Gson在双向解析时都会忽略</li>
<li>如果A中的变量赋值为null，Gson在toJson的时候会忽略该变量，在输出的json中也不会含有该字段(变量)。</li>
<li>如果A中有字段(变量)id，但json中没有，则id会初始化为对应的默认值(int 0,obj null)<br>如果A中没有字段(变量)id，但json中有，则生成A对象时会忽略id这个变量。</li>
<li>Gson是不含有状态量的对象，因此只需要初始化一次就可以反复使用。</li>
<li>Gson提供了另外一种构造器GsonBuilder类，来为用户提供需要自定义的Gson解析对象。</li>
</ol>
<p>##Gson还提供了很多自定义的功能</p>
<ul>
<li>使用@Since(versionCode)可以指定相应的版本对某个变量进行解析或者忽略。</li>
<li>还可以使用GsonBuilder的excludeFieldsWithModifiers()方法来忽略某些特殊修饰词进行修饰的成员变量的解析。</li>
<li>支持用户自定义的解析策略<br>更多自定义的功能，可以查看<a href="https://sites.google.com/site/gson/gson-user-guide" target="_blank" rel="external">Gson的帮助文档</a>。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-style-and-theme" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/08/style-and-theme/" class="article-date">
  	<time datetime="2014-09-08T12:34:00.000Z" itemprop="datePublished">2014-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/08/style-and-theme/">Theme And Style</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##Theme和Style的区别</p>
<ul>
<li>Theme是应用到一个Activity或者整个Application上的Style，而不是应用于某个View上，应用于某个View上的叫做Style。</li>
<li>Theme是针对窗体级别，改变窗体样式的，Style是针对窗体中的UI控件的，用来控件或者Layout的样式。</li>
<li>Theme和Style在定义的时候是一样的，都是定义在<code>/res/values/</code>目录下。</li>
<li>每个<code>&lt;style&gt;</code>都可以被应用到Application/Activity或者应用到某个View，应用到App的时候就叫Theme，应用到View的时候就叫Style。</li>
</ul>
<p>##定义一个Style</p>
<blockquote>
<p>在<code>&lt;resource&gt;</code>下的每个子节点 ，在编译的时候都会被转化为对象，通过他们定义的Style的名字来引用。</p>
</blockquote>
<p>如果想自定义一个Style要从何下手呢？完全从头做起？那你就错了，在定义Style的时候，不需要从头做起，<br>只需要继承Android提供的Style，并且对你需要自定义的属性进行修改即可。</p>
<p>例如：继承TextView的默认Style，并对其进行修改</p>
<figure class="highlight plain"><figcaption><span>lang: xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;GreenText&quot; parent=&quot;@android:style/TextAppearance&quot;&gt;</span><br><span class="line">        &lt;item name=&quot;android:textColor&quot;&gt;#00FF00&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你想继承自己定义的Style，而不是系统默认的Style的话，你可以直接在自定义Style名后面加上“.”再<br>加新的属性名即可，不需要再去写<code>parent</code>。例如：创建一个新的Style并继承上面自定义的GreenText</p>
<figure class="highlight plain"><figcaption><span>lang: xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=“GreenText.Big&quot;&gt;</span><br><span class="line">        &lt;item name=&quot;android:textSize”&gt;30sp&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>##Style的属性（Properties）<br>从上面的介绍知道了如何自定义一个Style，你只需继承Android默认的Style并且重写其中你需要自定义的字<br>段，那么都有哪些自定义的字段是可以重写的呢？你可以从<code>R.attr</code>获得所有可以重写的属性信息。但是不是所<br>有的<code>R.attr</code>中的属性都适用于某个指定的View，你需要参考指定的View的属性信息来确定哪些信息是可以被<br>重写的。如果你给一个View指定了一些它不支持的属性，他会自动忽略这些属性。有些属性不适合于任何View，<br>他只对Window有效这些属性只能用作Theme的属性去使用，如何区分哪些是对View有效哪些对其无效呢？<br>在<code>R.attr</code>中所有以<code>Window</code>开头的属性都是对View无效的，只能用做Theme属性去使用，其余的可以<br>用View的属性。</p>
<p>##Style的应用<br>应用Style的方式有两种:</p>
<ol>
<li>对于一个独立的View使用Style，只需要在View的布局文件中加入<code>style=“@style/xxxStyle”</code>即可。</li>
<li>对整个Application或者 Activity使用Style(这个Style就是Theme)，只需要<br>在Android manifest文件的<application>或者<activity>标签内加上<code>android:theme</code>属性即可。</activity></application></li>
</ol>
<p>当Style应用给一个View的时候，这个Style只会对这个View有效，如果这个View是一个ViewGroup的话，<br>那么也仅仅是对这个ViewGroup这个控件有效，对于ViewGroup内部的View是没有任何效果的。如果想对这<br>个ViewGroup中的所有View都有效的话，那么应该将这个Style当做Theme来使用，而非Style来使用。<br>(当Theme使用的意思就是将这个Style应用到这个ViewGroup所在的Activity或者整个Application)</p>
<p>##Theme的选择<br>在选择使用什么样的Theme的时候，需要根据系统所支持的版本来确定，高版本的系统中会提供一些Theme是低<br>版本中不含有的。因此为了对各个版本兼容，Android在res目录下生成了多个values目录来提供对不同版本的<br>兼容。</p>
<p>举例如下：<br>假如当前版本为3.0以下，我们可以在res/values目录下定义style.xml:</p>
<figure class="highlight plain"><figcaption><span>lang: xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">     ···</span><br><span class="line">    &lt;style name=&quot;LightThemeSelector&quot; parent=&quot;android:Theme.Light”&gt;</span><br><span class="line">          ···</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">     ···</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>假如当前版本为3.0~4.0之间我们可以在res/values-v11目录下定义style.xml:</p>
<figure class="highlight plain"><figcaption><span>lang: xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">     ···</span><br><span class="line">    &lt;style name=&quot;LightThemeSelector&quot; parent=“android:Theme.Holo.Light”&gt;</span><br><span class="line">          ···</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">     ···</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>Holo主题是在API 11后提供的。如果在API 14以上，我们可以在res/values-v14目录下定义。<br>这样就可以很好的兼容多个版本，保持视觉上的统一。</p>
<p>##如何去引用资源</p>
<p>引用可以通过：@、？来引用。那么这两者的区别在哪里呢？“?”主要用来引用私有资源，“@”主要用来引用公有<br>资源。因为Android的资源Style等之间存在着继承关系，因此”?”就相当于类中的”this”,而”@“则相当于一<br>个公共的对象（R），来对资源进行引用。通常”?”引用的资源都是当前包(目录)中的，而”@“引用的资源既可以<br>是当前目录中的也可以不同目录中的。在对Android属性继承修改的时候，我们可能需要别的属性，如果该属性<br>在父类中不存在的话，那么我们可以在<code>res/values/attrs.xml</code>中通过<code>declare-styleable</code>标签来定<br>义我们所需要的属性资源以及这些属性资源的<code>format</code>格式，然后就可以在Style文件中直接使用。</p>
<p>##资源<br><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/styles.xml" target="_blank" rel="external">Android的Style资源</a></p>
<p><a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/themes.xml" target="_blank" rel="external">Android的Theme资源</a></p>
<p><a href="http://developer.android.com/reference/android/R.attr.html" target="_blank" rel="external">Android的属性资源</a></p>
<p><a href="http://developer.android.com/reference/android/R.styleable.html#Theme" target="_blank" rel="external">可以在Theme中使用的属性</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 TedYin
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>