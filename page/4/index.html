<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>TedYin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Half Programer">
<meta property="og:type" content="website">
<meta property="og:title" content="TedYin's Blog">
<meta property="og:url" content="http://www.tedyin.me/page/4/index.html">
<meta property="og:site_name" content="TedYin's Blog">
<meta property="og:description" content="Half Programer">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TedYin's Blog">
<meta name="twitter:description" content="Half Programer">
  
    <link rel="alternative" href="/atom.xml" title="TedYin&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xii1s.com1.z0.glb.clouddn.com/me.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">TedYin</a></h1>
		</hgroup>

		
		<p class="header-subtitle">快乐比生命更重要！</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/TedYin" title="github">github</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">TedYin</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xii1s.com1.z0.glb.clouddn.com/me.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">TedYin</h1>
			</hgroup>
			
			<p class="header-subtitle">快乐比生命更重要！</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/TedYin" title="github">github</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-Tough-regime-cranks-out-test-winners" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/06/06/Tough-regime-cranks-out-test-winners/" class="article-date">
  	<time datetime="2014-06-05T16:00:00.000Z" itemprop="datePublished">2014-06-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/06/Tough-regime-cranks-out-test-winners/">Tough regime cranks out test winners</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://www.tedyin.me/images/201406061227.jpg" alt="School"></p>
<p><em>Students prepare for the gaokao, China’s national university entrance exam, at No 2 Middle School in Nanchang, the capital of Jiangxi province. ZHOU MI / XINHUA</em></p>
<blockquote>
<p>####<strong>大意：又是一年一度高考，每个经历过高考过的人，无论最后结果是好是好，都或多或少的会以自己的方式祭奠那曾经或喜或悲逝去的岁月，那时的我们思想简单，为了高考全力以赴，貌似只要考上大学，以后便是康庄大道，那时候的日子枯燥甚至让人窒息，但是我们简单坚定。对于高考制度，我不予置评，虽然简单粗暴，但是却是目前最公平的选拔人才的方式。今晚让我们一起祈祷，祈祷每个怀揣梦想的孩子静心入睡，放飞梦想。</strong></p>
<p>It’s <code>make-or-break</code> time for millions of high school students in China.</p>
</blockquote>
<pre><code>make-or-break:
英 [meik ɔ: breik] 美 [mek ɔr brek] 
conj. 不成则败 孤注一掷的
</code></pre><blockquote>
<p>Saturday morning signals the start of two days of <code>grueling</code> activity, both mental and physical, as students take the national university entrance exam known as gaokao. Because success in the exam can open the door to a <code>well-paid job</code> and <code>high social standing</code>, the pressure on the students can be overwhelming.</p>
</blockquote>
<pre><code>Grueling:
英 [&apos;grʊəlɪŋ] 美 [ˈɡruəlɪŋ, ˈɡrulɪŋ] 
adj. 紧张的，激烈的，使极度疲劳的 
adv. 紧张地，激烈地

well-paid job :一份不错的工作

high social standing:高社会地位的

overwhelming:
英 [ˌəʊvəˈwelmɪŋ] 美 [ˌovɚˈhwɛlmɪŋ, -ˈwɛl-] 
adj. 势不可挡的，压倒一切的，巨大的；
压倒一切的欢乐
</code></pre><blockquote>
<p>However, few students are as committed, or prepared for gaokao success, as those at Hengshui High School in Hebei province, which has <code>gained</code> <code>fame</code> - and some criticism - for its <code>tough</code> <code>regime</code> and <code>impressive</code> success rate.</p>
</blockquote>
<pre><code>Gained:
英 [geɪnd] 美 [geɪnd] 
v. 获得( gain的过去式和过去分词 )；
赢得；增加；（钟、表）走快

fame:
英 [feɪm] 美 [fem] 
n. 名声；名望；传闻；
传说 vt. 使闻名；
使出名；使有名望 

tough:
英 [tʌf] 美 [tʌf] 
adj. 坚强的，坚韧的，不屈不挠的；
艰苦的，困难的，难办的；
牢固的，强壮的；粗暴的
n. 粗暴的人；暴徒，恶棍 
vt. &lt;口&gt;忍耐，忍受（常与out连用） 
adv. 强硬地，顽强地；
以强硬的态度

regime
英 [reɪˈʒi:m] 美 [reˈʒim, rɪ-] 
n. 政治制度，政权，政体；
管理，方法；
[医]养生法；（病人等的）生活规则

impressive
英 [ɪmˈpresɪv] 美 [ɪmˈprɛsɪv] 
adj. 给人印象深刻的，感人的；
引人注目的；可观的；显赫
</code></pre><blockquote>
<p>For senior students, the day begins at 5:30 am and lasts until 10:10 pm, with every hour <code>punctuated</code> by the <code>incessant</code> ringing of bells that announce classes, break times, self-study periods, <code>extracurricular</code> activities and <code>dormitory</code> time.</p>
</blockquote>
<pre><code>Punctuated
[ˈpʌŋktʃu:ˌeɪtid] 
v. （在文字中）加标点符号，
加标点( punctuate的过去式和过去分词 )；
不时打断某事物

incessant
英 [ɪnˈsesnt] 美 [ɪnˈsɛsənt] 
adj. 不停的，持续不断的；
无尽无休

extracurricular
英 [ˌekstrəkə&apos;rɪkjʊlə] 美 [ˌekstrəkə&apos;rɪkjələ] 
adj. 学校课程以外的；课外

dormitory
[&apos;dɔ:mətrɪ] 美 [ˈdɔrmɪˌtɔri, -ˌtori] 
n. （学校等的）宿舍 集体寝室
（在市内工作的人的）郊外住宅区 
adj. 住宅区的
</code></pre><blockquote>
<p>The students spend most of their time in <code>cramped</code> classrooms. Although the designated food breaks last 40 minutes, many students rush to the <code>canteen</code> and <code>wolf down</code> their food in less than five minutes so they can <code>snatch</code> an extra few minutes for their studies.</p>
</blockquote>
<pre><code>Cramped
英 [kræmpt] 美 [kræmpt] 
adj. 狭窄的；难懂的
 v. 夹紧(cramp的过去式)；
 用夹钳夹；约束

canteen
英 [kænˈti:n] 美 [kænˈtin] 
n. 小卖部；食堂，小饭馆；
水罐；餐具盒，炊具箱

wolf down
英 [wulf daun] 美 [wʊlf daʊn] 
v. 狼吞虎咽地吃

snatch
英 [snætʃ] 美 [snætʃ] 
n. 抢；一阵子，一下工夫；
很小的数量；&lt;美俚&gt;诱拐
 vi. 作出握住或抢夺的动作；
 很快接受 
vt. 抢夺，夺得；
及时救助；[体育运动]举重
</code></pre><blockquote>
<p>Sun Yajian, a freshman at Shanghai International Studies University, who graduated from Hengshui High last year, said he even ran to the canteen to save time. “I usually spent three to five minutes eating dinner. Once, I even finished my meal in less than two minutes,” the 20-year-old said. “I only ate to fill my stomach. I didn’t care what I ate, just as long as I was full.”The <code>regime</code> is tough. In addition to teachers and members of the students union who <code>patrol</code> the school to ensure discipline, cameras constantly <code>scan</code> the classrooms searching for students neglecting their work. Cell phones are not allowed, and if you don’t consider the 20 minutes <code>allocated</code> daily for watching news broadcasts, or the weekly class meetings, which occasionally feature an <code>inspirational</code> video, as <code>entertainment</code>, then there’s no entertainment, either.</p>
</blockquote>
<pre><code>Patrol
英 [pə&apos;trəʊl] 美 [pəˈtrol] 
n. 巡逻，巡查；
巡逻队，侦察队；
童子军小队
 vt.&amp; vi. 巡逻，巡查

scan
英 [skæn] 美 [skæn] 
vt. &lt;计&gt;扫描；
细看；细查；
（雷达）对…进行扫描 
n. 扫描；浏览
；审视；
（雷达/屏面上的）光点 
vi. （光束、雷达等）扫描；
扫略；（诗歌）符合韵律；
标出诗歌的格律

allocated
英 [&apos;æləkeɪtɪd] 美 [&apos;æləkeɪtɪd] 
v. 分配，分派( allocate的过去式和过去分词 )；
把…拨给

inspirational
英 [ˌɪnspə&apos;reɪʃənl] 美 [ˌɪnspə&apos;reɪʃənl] 
adj. 给予灵感的，带有灵感的；
鼓舞人心的

entertainment
英 [ˌentəˈteɪnmənt] 美 [ˌɛntɚˈtenmənt] 
n. 娱乐，消遣；
招待，款待
；娱乐节目
</code></pre><blockquote>
<p>The students are usually given one day off every four weeks, after taking a monthly test, but they are also tested every day and once a week. The results are posted publicly to show the changes in each student’s ranking.The school is also famed for its tight management of extracurricular activity. Ren Yueming, a freshman at China University of Political Science and Law in Beijing, graduated from Hengshui High last year. She said students are not even allowed to see their parents privately at the school gates, and with the exception of formal holidays, they have to present the <code>doorkeeper</code> with a permit from their teacher if they want to leave the <code>campus</code>.</p>
</blockquote>
<pre><code>Doorkeeper
英 [ˈdɔ:ki:pə(r)] 美 [ˈdɔrˌkipɚ, ˈdor-] 
n. 看门人

campus
英 [&apos;kæmpəs] 美 [ˈkæmpəs] 
n. （大学）校园；
学校范围内；
大学或其分校；
大学生活
</code></pre><blockquote>
<p>In class, any activity unrelated to study can be considered a <code>breach</code> of discipline, including <code>shuffling papers</code> and chatting, said Sun. “Students have to follow the teachers in class. You can’t do things based on your own plans,” he said.</p>
</blockquote>
<pre><code>Breach
英 [bri:tʃ] 美 [britʃ] 
n. 破坏；破裂；缺口；
违背 vt. 攻破；
破坏，违反

shuffling papers：打牌
</code></pre><blockquote>
<p>The demanding system seems to pay <code>dividends</code>, though: In 2013, the school sent 104 graduates to Tsinghua University and Peking University, China’s <code>most-prestigious</code> universities. The figure accounted for 80 percent of the two universities’ total enrollment from Hebei, and 20% of the university candidates from Hebei who scored more than 600 points in the gaokao were graduates of Hengshui High.</p>
</blockquote>
<pre><code>Dividends
英 [&apos;dɪvɪdendz] 美 [&apos;dɪvɪdendz] 
n. 红利( dividend的名词复数 )；
股息；被除数；
（足球彩票的）彩金

most-prestigious：最负盛名的
</code></pre><blockquote>
<p>Last year was no <code>flash in the pan</code>, either. The school has been ranked Hebei’s number one for university enrollment for 14 <code>consecutive</code> years.However, while no one doubts the school’s success, critics argue that the routine <code>stifles</code> creativity and independent thought, and some have even labeled it an “academic factory”, focused purely on gaokao success to the <code>exclusion</code> of other aspects of the students’ <code>personalities</code>.</p>
</blockquote>
<pre><code> flash in the pan：昙花一现

consecutive
英 [kənˈsekjətɪv] 美 [kənˈsɛkjətɪv] 
adj. 连续的，连贯的；
[语]表示结果的

stifles
[ˈstaiflz] 
v. （使）窒息， 
（使）窒闷( stifle的第三人称单数 )；
镇压，遏制 

exclusion
英 [ɪkˈsklu:ʒn] 美 [ɪkˈskluʒən] 
n. 拒绝，杜绝；
排除，驱逐；
被排斥在外的人（或事物）；
排外主义

personalities
英 [ˌpɜ:sə&apos;nælɪtɪz] 美 [ˌpɜ:sə&apos;nælɪtɪz] 
n. （对某人容貌、性格等所进行的）人身攻击；
人身攻击( personality的名词复数 )；
人格；名人；特色
</code></pre><blockquote>
<p>“If I were offered the chance to choose again, I wouldn’t spend the three years at such a school, and I would never let my children attend such an institution,” said Li Jingnan, a graduate student majoring in <code>accountancy</code> at Tianjin University of Finance &amp; Economics.</p>
</blockquote>
<pre><code>Accountancy
英 [əˈkaʊntənsi] 美 [əˈkaʊntənsi] 
n. 会计工作，会计职业；
会计学
</code></pre><blockquote>
<p>Li said the academic day was even longer when he studied at Hengshui High 10 years ago. The 28-year-old said he was unhappy with the mode of teaching employed, claiming that it “tightly controls students”, making them mentally “<code>rigid</code>“, something that left him unprepared for life in the outside world. “I found myself <code>at a loss</code> when I entered university, not knowing what I wanted or what to do. I had lost my sense of direction after three years at the school where everything was <code>rigorously</code> controlled,” he said. </p>
</blockquote>
<pre><code>Rigid:
英 [ˈrɪdʒɪd] 美 [ˈrɪdʒɪd] 
adj. 严格的；僵硬的；
（规则、方法等）死板的；刚硬的，顽固的

at a loss:
英 [æt ə lɔs] 美 [æt e lɔs] 
不知所措
亏本；困惑；
神思恍惚

Rigorously:
英 [&apos;rɪɡərəslɪ] 美 [ˈrɪɡərəslɪ] 
adv. 严厉地，残酷地；
严密地
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-learn-action-bar" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/06/04/learn-action-bar/" class="article-date">
  	<time datetime="2014-06-03T16:00:00.000Z" itemprop="datePublished">2014-06-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/04/learn-action-bar/">Learn ActionBar</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#ActionBar Overview<br>ActionBar有如下几个特点:</p>
<ul>
<li>ActionBar 是android系统提供专门用来应用导行功能的一个控件</li>
<li>提供一种非常便捷和高效的导航方式</li>
<li>支持不同页面间的导航功能切换</li>
</ul>
<p>是android在3.0时添加的一个重要组件。它可以通过support library的形式被集成到2.1及其以上的版本中使用。</p>
<p>#ActionBar Use<br>下面主要介绍一下使用support v7 library中的ActionBar。</p>
<p>###Add ActionBar</p>
<ol>
<li>先<a href="http://developer.android.com/tools/support-library/setup.html" target="_blank" rel="external">导入v7包</a>.</li>
<li>你的Activity必须继承自ActionBarActivity</li>
<li>在你的应用中使用Theme.AppComapt主题或者使用继承自Theme.AppCompat主题的自定义。</li>
</ol>
<p><em>注：Theme.AppCompat 相当于3.0中添加的Theme.Holo主题</em><br>这样在你的Activity中就完成了ActionBar的添加。</p>
<p>###Removing the action bar<br>关闭ActionBar的方法如下:</p>
<ul>
<li>getSupportActionBar()得到ActionBar的对象，调用hide方法即可关闭ActionBar。如果想再次显示，则可以是用show方法即可</li>
<li>使用Them.AppCompat.NoActonBar方法，不使用Actionbar</li>
</ul>
<blockquote>
<p>注意</p>
<ul>
<li>support包中的getSupportXXX()方法就等同于在加入该控件的API level以上的SDK中调用 getXXX()方法。</li>
<li>在使用ActionBar的show()和hide()方法的时候，会导致界面布局调整，整个界面会被重绘，增加性能成本，如果需要经常对ActionBar进行隐藏和显示操作，我们可以使用ActionBar Overlay来完成这个需求。ActionBar Overlay的实现方式是使用Custom的主题继承自Theme.AppCompat并且设置windowActionBarOverlay这个属性为true即可。它会使得ActionBar浮在Layout的上面，此时如果对ActionBar进行show或者hide操作，就不会进行界面重绘了。如果你的布局不想被ActionBar挡住，则可以在该布局的根一级的Layout中加入paddingTop 或者marginTop属性，给他们赋值为”?android:attr/actionBarSize”即可。</li>
</ul>
</blockquote>
<p>###Add Action Items</p>
<p>上面已经有了ActionBar，但是如何让这个ActionBar进行工作呢?因此我们需要给ActionBar添加内容。ActionBar相当于一个导航容器，他是一个什么都能接收到东西。你可以自定义许多内容给他，他都可以将这些东西组织并展现出来。ActionBar跟3.0之前的版本中的菜单一样，提供一堆功能导航，只是在3.0之后将它的作用明确了，尤其是在4.0之后配合Android Design一起使得它的功能性更明确了就是处理Activity中的动作交互。添加Action Item我们只需在res/menu/xxx_menu.xml中定义好要添加的Item内容，然后重载OnCreateOptionsMenu()方法，并且在其中使用MenuInflater将这个xml布局inflate成Menu对象，并且设置给ActionBar即可。</p>
<pre><code>@Override
public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu items for use in the action bar
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.main_activity_actions, menu);
    return super.onCreateOptionsMenu(menu);
}
</code></pre><p>xxx_menu.xml布局文件如下：</p>
<pre><code>&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
    &lt;item android:id=&quot;@+id/action_search&quot;
          android:icon=&quot;@drawable/ic_action_search&quot;
          android:title=&quot;@string/action_search&quot;/&gt;
    &lt;item android:id=&quot;@+id/action_compose&quot;
          android:icon=&quot;@drawable/ic_action_compose&quot;
          android:title=&quot;@string/action_compose&quot; 
          yourStyle:showAsAction=&quot;ifRoome&quot;/&gt;
&lt;/menu&gt;
</code></pre><p><em>yourStyle:showAsAction</em>是需要用户自定义的属性，在3.0以上版本中属于Android的默认属性。<code>showAsAction</code>属性的选项有<code>ifRoom/always/never</code>,作用如下:</p>
<ul>
<li>ifRoom 表示如果有做够的空间，Action将会显示在ActionBar，否则会隐藏到overFlow中</li>
<li>always 表示永远显示在ActionBar上</li>
<li>never表示永不显示在ActionBar上，即永远显示在overflow中</li>
</ul>
<p>当用户点击上述按钮的时候会调用<code>onOptionsItemSelected(MenuItem item)</code>方法，并且将被点击的Item传入到Menu中去，因此我们可以重载该方法并且在该方法中处理按钮点击事件，和处理普通的点击事件一样。</p>
<blockquote>
<p>如果你是在Fragment中使用<code>OnCreateOptionsMenu</code>方法inflate一个Menu到ActionBar上，当你在Fragment中点击ActionBar中的Action时，如果你在<code>OnOptionsItemSelected</code>中使用了<code>super.onOptionsItemSelected</code>方法，系统会先调用Activity中的<code>OnOptionsItemSelected()</code>方法去处理，处理完成后才会调用Fragment中的这个方法处理，如果不加则会直接调用Fragment中的<code>OnOptionsItemSelected()</code>方法处理。</p>
</blockquote>
<p>###Using Split Action bar<br>Split ActionBar其实就是对ActionBar的分割，当用户使用窄屏幕的时候，如果在ActionBar上面不够放，系统会将Actions都放在屏幕的底部，来为导航和标题留出空间。使用Split Action Bar的效果图如下第1~2图。</p>
<p><img src="http://www.tedyin.me/images/201406090916.png" alt="normal ActionBar"> </p>
<p>使用Split action bar 的方法如下:</p>
<ul>
<li>给<code>&lt;application&gt;</code>标签添加属性 <code>uiOptions=&quot;splitActionBarWhenNarrow&quot;</code>,使得所有的Activity都应用Split Action Bar或者给某些指定的<code>&lt;activity&gt;</code>标签添加该属性，指定某几个Activity应用Split Action Bar。这个属性只能用于API level 14及其以上，如果想对其以下的版本进行兼容，需要在<code>&lt;activity&gt;</code>标签下使用<code>&lt;meta-data&gt;</code>标签来指定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity ... &gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name=&quot;android.support.UI_OPTIONS&quot;</span><br><span class="line">        android:value=&quot;splitActionBarWhenNarrow&quot;/&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>
<p>如果Activity使用了该属性，并且对于ActionBar上的icon和title分别使用<code>setDisplayShowHomeEnable(false)</code>和<code>setDisplayShowTitleEnable(false)</code>进行隐藏，那那么在有tab的情况下，main ActionBar也会被自动隐藏，效果如上图中第2~3图。</p>
<p>###Navigating Up with the App Icon<br>Navigating Up返回到上一级Activity，有两种方法：</p>
<ol>
<li><p>在<code>&lt;activity&gt;</code>标签中设置<code>android:parentActivityName=&quot;me.tedyin.todo.MainActivity&quot;</code>（API level 16及其以上）即可，对于API level低于16的可以使用<code>&lt;meta-data&gt;</code>标签来指定</p>
<p> &lt;activity  …             android:parentActivityName=”com.example.app.MainActivity”</p>
<pre><code>&gt;
&lt;meta-data
    android:name=&quot;android:support.PARENT_ACTIVITY&quot;
    android:value=&quot;com.example.app.MainActivity&quot;
    /&gt;
</code></pre> <activity>

<blockquote>
<p><em>注意：上面<code>android:parentActivityName</code>的值必须和下面meta-data的value中定义的值相同。</em></p>
</blockquote>
</activity></li>
</ol>
<ol>
<li>在代码中使用<code>getSupportActionBar().setDisplayHomeAsUpEnable(true)</code>来开启navigate up 按钮。</li>
</ol>
<p>当Up Action 打开后，此时Icon前面会出现一个系统默认的返回按钮，表示可以返回到父Activity中。当点击该Up Action的时候，会调用<code>OnOptionsItemSelected(MenuItem)</code>方法，传入的是Id为<code>android.r.id.home</code>的<code>MenuItem</code>对象，我们可以重载上述方法来处理此点击事件。        </p>
<blockquote>
<p>如果我们的应用在关闭的情况下被第三方打开某个Activity，那么此时我们的activity则是在一个新的task stack中，此时该Activity的Logic Parent是不在该stack中的，为了保证操作的连贯性，你应该处理这种情况。我们可以使用NavUtils 来帮助我们处理，处理的过程如下:</p>
<ol>
<li>调用shouldUpReCreateTask(Context , Intent)来检查你的Activity是否存在一个App ‘s stack，包含你的Activity，如果返回true（不存在，需要重新创建），如果返回false（存在，不需要重新创建）。</li>
<li>如果需要重新创建，则需要使用TaskStackBuilder来方便我们创新的task stack 。</li>
</ol>
</blockquote>
<p>最佳实践如下:</p>
<pre><code>//重载OnOptionsItemSelected(MenuItem)方法
case android.R.id.home:
    Intent upIntent = NavUtils.getParentActivityIntent(this);
    if(NavUtils.shouldUpRecreateTask){
        //需要重新创建一个Task，来保存当前Activity的Parent Activity 到新的task stack中
        TaskStackBuilder.create(this).addNextIntentWithParentStack(upIntent).startActivitise();
    }else{
        //不需要的新建一个task来维护当前Activity和它的Parent Activity之间的stack关系，所以直接启动切换到父Activity即可
        NavUtils.navigateUpTo(this,upIntent);
    }
break;
</code></pre><blockquote>
<p>如果是从Fragment中处理Navigation Up,我们需要覆写onSupportNavigateUp()方法去处理fragment transaction。通常我们会用popBackStack()方法处理fragment切换到Parent Fragment中去。</p>
</blockquote>
<p>###Adding an Action View<br>Action View就是显示在ActionBar上面的Widget，他可以不需要改变Activity Fragment，并且也不会替换原有的ActionBar，不会导致界面重绘等问题，可以快速提供一个丰富的Action交互空间。我们常见的Search操作就是使用的ActionView来实现的。</p>
<p>####声明一个ActionView有如下方法:</p>
<ul>
<li>使用<code>actionLayout</code>属性来指定一个resource资源来生成一个ActionView</li>
<li>使用<code>actionViewClass</code>属性来指定一个Widget来生成一个ActionView</li>
</ul>
<p>添加一个ActionView的方法如下:(此处添加一个Widget来作为ActionView)</p>
<pre><code>&lt;menu ... &gt;
    &lt;item  android:id = &quot;@+id/action_search&quot;
        android:title=&quot;search&quot;
        andorid:icon=&quot;@drawable/icon&quot;
        yourStyle:showAsAction=&quot;ifRoom|collapseActionView&quot;
        yourStyle:actionViewClass=&quot;android.support.v7.widget.SearchView&quot; 
        &gt;
&lt;/menu&gt;
</code></pre><p>上述中collapseActionView的作用即为当点击Action Button时触发ActionView。</p>
<p>上面声明了ActionView，我们可以在OnCreateOptionsMenu(Menu)方法中inflate出这个ActionView并将其加入到ActionBar中。</p>
<pre><code>@Overried
public void OnCreateOptionsMenu(Menu menu){
    getMenuInflater().inflate(R.layout.menu_actions,  menu);
    MenuItem searchItem = menu.findItem(R.id.action_search);
    SearchView searchView = (SearchView)MenuItemCompat.getActionView(searchItem);
    ...
    return super.OnCreateOptionsMenu(menu);
}
</code></pre><p>使用MenuItemCompat的静态方法getActionView(MenuItem)即可得到ActionView。<br><em>在API leve 11及其以上，<code>MenuItem</code>对象也提供<code>getActionView()</code>方法，即：<code>menu.findItem(R.id.action_search).getActionView()</code></em></p>
<p>###Handling collapsible action views<br>上面只讲述了如何打开Action view但是没有告诉你怎么collapse 一个 action view，下面就讨论一下如何collapse一个action view。当你点击返回键或者Up navigate button时，ActionView会自动收起。我们可以使用<code>OnActionExpandListener</code>来监听ActionView的打开与关闭。</p>
<pre><code>@Override
public void OnCreateOptionsMenu(Menu menu){
    MenuItemCompat.setOnActionExpandListener(menuItem, new OnActionExpandListener(){
        @Overried
        public boolean onMenuItemActionCollapse(MenuItem item){
            //do something
        }
        @Overried
        public boolean onMenuItemActionExpand(MenuItem item){
            //do something
        }
    });
}
</code></pre><p>###Add an Action Provider<br>每一个ActionProvider都已经定义好了自己的行为，因此你不需要再在OnOptionItemSelected()方法中对ActionProvider处理。虽然不用处理，但是如果你需要监听ActionProvider的行为的话，依然可以在OnOptionsItemSelected()方法中监听处理，但是一定要注意，然会值应该为false，否则ActionProvider无法收到点击事件。如果ActionProvider提供一个子菜单的话，那么子菜单中的点击事件不会调用OnOptionsItemSelected()方法。使用了ActionProvider我们需要处理的其实就是<br>ActionProvider使用方法如下:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
      xmlns:yourapp=&quot;http://schemas.android.com/apk/res-auto&quot; &gt;
    &lt;item android:id=&quot;@+id/action_share&quot;
          android:title=&quot;@string/share&quot;
          yourStyle:showAsAction=&quot;ifRoom&quot;
          yourStyle:actionProviderClass=&quot;android.support.v7.widget.ShareActionProvider&quot;
          /&gt;
    ...
&lt;/menu&gt;    
</code></pre><p>上述中<code>actionProviderClass</code>属性，在API Level 11以下需要自定义实现。添加完了布局文件，我们需要做的就是给在初始化ActionProvider的时候传入正确的Intent来保证他会按照我们设置的方式来工作。因为Context会变化，因此必须在每次更新的时候都要调用一次<code>setShareItent()</code>来保证我们Inent的正确。</p>
<pre><code>private ShareActionProvider shareActionProvider;
//...
@Overried
public boolean OnCreateOptionsMenu(Menu menu){
    getMenuInflater.inflate(R.id.menu,menu);
    //set up share action provider
    MenuItem shareItem = menu.findItem(R.id.action_share);
    shareActionProvider = (ShareActionProvider)MenuItemCompat.getActionProvider(shareItem);
    //set share intent
    Intent intent = new Intent(Intent.ACTION_SEND);
    intent.setType(&quot;image/*&quot;);
    shareActionProvider.setShareIntent(intent);
    return supper.OnCreateOptionsMenu(menu);
}
</code></pre><p><code>ShareActionProvider</code>默认会根据用户的使用频率动态的调整每个Item的先后顺序，这个排序是保存在一个私有的文件<code>DEFAULT_SHARE_HISTORY_FIILE_NAME</code>中，我们可以使用<code>ShareActionProvider</code>对象的<code>setShareHistoryFileName(&quot;example.xml&quot;)</code>方法来指定一个排序文件，按照我们喜欢的方式进行自定义排序。</p>
<p>###Creating a custom action provider<br>使用自定义的Action Provider可以很方便的让你去管理和重用那些Action动作，而不用你再去每个Activity或者Fragment中去处理Action的行为。<br>创建自定义Action Provider的步骤如下:</p>
<ol>
<li>继承ActionProvider这个类</li>
<li>实现ActionProvider()这个构造方法，他会传递一个Application Context 给你，你需要保存这个Context为后面其他回调方法提供。</li>
<li>实现<code>onCreateActionView(MenuItem menuItem)</code>方法，这个方法是用来inflate action view的。</li>
<li>实现<code>onPerformDefaultAction()</code>这个方法是在触发Action的时候系统调用的。这个方法默认是不实现任何操作，并且返回false</li>
</ol>
<p><em>注:如果你的ActionProvider是放在Overflow中的，而且它有subMenu，那么在点击时<code>onPerformDefaultAction()</code>这个方法是不会被调用的</em></p>
<p>###Adding  Navigation Tabs<br>Tabs 提供了方便的导航，他的添加方法如下:</p>
<ol>
<li>实现<code>ActionBar.TabListener</code>接口。这个接口提供了许多tab事件的回调方法，你可以在这个接口中处理和tab相关的操作。</li>
<li>对于每个你想添加的tab你在初始化这个tab的时候，可以通过<code>setTabListener()</code>方法添加<code>TabListener</code>，也可以同过<code>setTabTitle(title)</code>来设置tab的属性等。</li>
<li>当初始化好一个tab后可以使用<code>addTab(yourTab)</code>方法将它加入到ActionBar去。</li>
<li>必须调用<code>setNavigationMode(NAVIGATION_MODE_TABS)</code>方法让tab显示出来。</li>
</ol>
<blockquote>
<p>注意:</p>
<ol>
<li>ActionBar.TabListener的回调方法不会指定哪个fragment和具体的tab绑定，它只会提供当前选中了哪个tab，你需要自己根据需要绑定，下面介绍一种绑定实现.</li>
<li>初始化一个Tab的方法: Tab tab = actionBar.newTab().setText(“tab”).setTabListener(tabListener);   然后 actionBar.addTab(tab);即可。</li>
</ol>
</blockquote>
<pre><code>//TabListener的实现
public static class TabListener&lt;T extends Fragment&gt; implements ActionBar.TabListener{
    private Fragment mFragment;
    private final String mTag;//用来唯一标识Fragment在FragmentTransaction中的key
    private final Activity mActivity;//用来初始化Fragment
    private final Class&lt;T&gt; mClass;//Frangment的类，用来初始化fragment
    public TabListener(Activity activity, String keyTag, Class&lt;T&gt; clz){
        this.mTag = keyTag;
        this.mActivity = activity;
        this.mClass = clz;
    }
    public void onTabSelected(Tab tab, FragmentTransaction ft){
        // when tab selected
        //如果没有初始化，则进行初始化
        if(mFragment == null){
            mFragment = Fragment.instantiate(mActivity, mClass.getName());
            ft.add(android.R.id.content,mFragment,mTag);
        }else{
            //存在则直接attach显示
            ft.attach(mFragment);
        }
    }
    public void onTabUnSelected(Tab tab, FragmenTransaction ft){
        //whne tab unselected
        if(mFragment != null){
            //detach ，因为别的Fragment要attach显示
            ft.detach(mFragment);
        }
    }
    public void onTabReselected(Tab tab. FragmentTransaction ft){
        //user select the already selected tab , Usually do nothing. 因为他就是当前显示的，所以不需要操作什么。
    }
}
</code></pre><blockquote>
<p><strong>注意：在回调中我们禁止调用commit()方法来确认fragment transaction，因为系统会为我们调用它，如果我们自己调用的话会出现异常。你同样也不能将这个fragment transaction 加入到back task stack中！</strong></p>
<p><em>上面的<code>android.R.id.content</code>是root view的Id，在不使用<code>setContentView</code>时使用它来作为Fragment的容器</em></p>
</blockquote>
<p>下面的代码使用了上面的TabListener，示例如下:</p>
<pre><code>@Overried
public void onCreate(Bundle savedInstanceState){
    super.onCreate(savedInstanceState);
    //use the android.R.id.content as the container for each fragment , it is the root view id. 因此不用setContentView()
    //setup action bar for tabs
    ActionBar actionBar = getSupportActionBar();
    actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);//显示tabs
    actionBar.setDisplayShowTitleEnable(false);
    Tab tab1 = actionBar.newTab().setText(&quot;tab1&quot;).setTabListener(new TabListener&lt;Fragment&gt;(this,&quot;tab1&quot;,MFirstFragment.class));
    actionBar.addTab(tab);
    Tab tab2 = actionBar.newTab().setText(&quot;tab2&quot;).setTabListener(new TabListener&lt;Fragment&gt;(thsi,&quot;tab2&quot;,MSecondFragment.class));
    actionBar.addTab(tab2);
}
</code></pre><p><em>未完待续~~</em></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SQLite-study" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/06/03/SQLite-study/" class="article-date">
  	<time datetime="2014-06-03T14:39:00.000Z" itemprop="datePublished">2014-06-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/03/SQLite-study/">SQLite Study</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SQLite学习"><a href="#SQLite学习" class="headerlink" title="SQLite学习"></a><center>SQLite学习</center></h1><p>##SQLite简介<br>SQLite是一个小型数据库，它被集成到Android系统中完成数据库部分。它不需要进行配置和管理，可以在Android系统中直接使用。</p>
<p>##SQLite使用</p>
<p>###1.SQLiteOpenHelper<br>SQLiteOpenHelper使用一个帮助类，通过继承它并实现onCreate方法和Upgrade方法，来管理我们的数据库。</p>
<ul>
<li>onCreate方法是framework层调用，当你要打开某个数据库，但是这个数据库不存在时，framework就会调用这个方法去创建一个数据库。</li>
<li>onUpgrade方法是在对数据库进行更新时调用的，当你的数据库版本增加时，你可以通过调用这个方法修改数据库或者删除数据库然后通过调用onCreate方法重现创建数据库。</li>
</ul>
<p>另外SQLiteOpenHelper还提供了getReadableDatabase方法和getWriteableDatabase方法去获取一个SQLDatabase对象。<br>上述两方法中都会使用SQLiteDatabase对象作为参数，这个类就代表了数据库。</p>
<p><strong>注意：</strong>对于数据库创建的最佳实践是，每个表都建一个类，并且在这个类中定义<em><code>static</code></em>的onCreate和onUpgrade方法，这些方法在SQLiteOpenHelper中被调用，这样你的SQLiteOpenHelper实现类就有很好的可读性了，即使你有很多的数据表。</p>
<p>###2.SQLiteDatabase<br><code>SQLiteDatabase</code>类是整个android数据库的基础类，它提供了对数据库操作的增删改查方法，另外还可以通过<code>execSQL</code>方法来执行SQL语句。<br><code>ContentValues</code>是对key/value的一个包装，使用它可以将要插入或者要修改的数据以key/value的形式进行封装，在使用相应增改方法的时候直接使用。</p>
<ul>
<li>rawQuery 是SQLDatabase的方法，他可以使用SQL语句直接查询。</li>
<li>query是推荐的查询方法，它的使用类似于Hibernate中的查询，只需要将参数查询条件等一参数的形式提供，就可以得到结果</li>
<li>Cursor对象，这个是查询的结果使用它可以遍历整个查询出的数据内容（table）</li>
<li>SQLiteBuilder是用来创建查询语句的</li>
</ul>
<p>###3.Cursor<br>这个类是查询结果的封装，使用他可以很方便的获取数据库查询结果。</p>
<ul>
<li>getCount()返回结果数据的条数</li>
<li>moveFirst 将游标指向第一条查询结果</li>
<li>moveNext 将游标指向下一条查询结果</li>
<li>isAfterLast 检查是否已经到达end</li>
</ul>
<p><strong>注意：</strong><code>Cursor</code>在使用完成后需要调用close关闭。（TDOO：如果不关闭怎么办）</p>
<p>###4.DAO在Android中的使用</p>
<p>DAO的作用就是对外提供增删改查接口，在他的内部封装了SQLiteDatabase，以及SQLiteOpenHelper，将常用的增删改查以静态方法的形式对外提供。并且还封装了一些对数据进行初步加工的方法。DAO的存在就是将应用层和数据持久层相互隔离，应用层需要操作数据时，只通过DAO来和持久层交互。在持久层的实现中可以引入CursorLoader之类的东西。在Android中的最佳实践是使用ContentProvider来访做DAO与数据层进行交互，因为Android为此提供了安全而完善的机制访问数据层。</p>
<p>##SQLite使用注意事项</p>
<ul>
<li>在对数据库进行操作的时候会访问文件系统，很有可能是耗时操作，因此建议放在异步线程进行数据库操作。</li>
<li>应用创建的数据库的位置为DATA/data/包名/databases/数据库名，其中DATA是Environment.getDataDirectory() 方法返回的路径。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Implementing-REST-Client-on-Android-4.0-and-below" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/06/03/Implementing-REST-Client-on-Android-4.0-and-below/" class="article-date">
  	<time datetime="2014-06-03T14:19:00.000Z" itemprop="datePublished">2014-06-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/03/Implementing-REST-Client-on-Android-4.0-and-below/">Implementing REST Client on Android 4.0 and below</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#General Overview</p>
<p>REST Client 是一个非常好的处理客户端与服务端之间交互的框架模型，他的机构如下：</p>
<p><img src="http://www.tedyin.me/images/framework.png" alt="framework"></p>
<p>他的最佳实践有以下几点：</p>
<ul>
<li>使用<code>Loaders</code>相关的类来进行异步加载</li>
<li>使用<code>Service</code></li>
<li>使用<code>ContentProvider</code>通过他可以使得我们更方便的去访问数据库，<code>ContentProvider</code>是Android提供的对外暴露数据的接口，使用它可以很好的将我们的数据层和应用层进行隔离。<code>ContentProvider</code>不是线程安全的，因此我们需要使用<code>Loader</code>框架来配合使用<code>ContentProvider</code>。</li>
</ul>
<h1 id="REST-With-Loaders"><a href="#REST-With-Loaders" class="headerlink" title="REST With Loaders"></a>REST With Loaders</h1><p>Loaders的特性：</p>
<ul>
<li>可以被Activity和Fragment来运行，并且所有Loaders的状态都是由LoaderManager来管理，因此我们不用担心Loaders的使用，他的生命周期是受系统管理的。</li>
<li>一般的REST调用都是一次性的，一旦你的Activity被放到background，你的REST调用可以被结束。</li>
</ul>
<p>REST 调用一般都是网络请求，也就是说一般都会是很耗时的操作，所以不应该放到主线程中进行，而是使用异步线程来执行网络操作，我们可以使用<code>AsyncTaskLoader</code>来实现这一目标，因此我们需要一个<code>RESTLoader</code>继承自A<code>AsyncTaskLoader</code>， 我们可以通过<code>LoaderManager</code>在Activity和Fragment中来调用<code>RESTLoader</code>。</p>
<p>#Start Our Project</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-markdown-study" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/05/25/markdown-study/" class="article-date">
  	<time datetime="2014-05-25T14:39:00.000Z" itemprop="datePublished">2014-05-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/25/markdown-study/">Markdown Study</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>写文章需要标题，表示标题的方法有：</p>
<pre><code>使用三个=号，来代表主标题
使用三个-号，来代表子标题
如果三个-号上无文字，则会在文本中生成虚线
除了上面的标题表示方式外，还看以使用#来表示标题：
#表示一级标题
##表示二级标题，一次类推#~######(6个)代表了1~6级的标题。
</code></pre><p>##标题<br>对于一个大标题，一般我们都会分为几个部分来讲解或记录，这些部分的小标题我们可以使用“+ - * ”来表示，他们三者的意义是一样的，都会转换成一个点（·）这样的无序标题。要是我们写到逻辑比较强的地方要分为1、2、3等条目时，也就是有序标题，我们可以使用1. 2. 3.等数字加“.”的方式表示有序标题。</p>
<p>##内容<br>标题写完了，下来我们要写具体的内容了，我们的文章是技术文章，需要用到架构图，我们可以用以下方式表示图片：<code>![别名](图片的url地址)</code>，前面的“!”不能去掉，因为去掉后，我们就只是显示一个链接，这个链接的名字就是“别名”。<br>当然如果我们想在给用户介绍，这个图片的来源以及图片作者的一些解释的时候，我们可以给图片加上Url链接效果：假如用x表示图片，那么这个链接效果就是<code>[x](目标链接Url)</code>，看到这里你就明白了，这个是可以嵌套使用的！</p>
<p>添加完了架构图片，下来我们需要引用一段原作者的名言来概括一下这张图片，我们可以使用“&gt;被引用的文字”这种写法，来添加一段引用。（这个也是可以嵌套使用的）</p>
<p>添加完引用后，我们要对作者的名言进行解释，我们需要添加一个注解，添加方法如下：</p>
<pre><code>“这个是名言的注解[^keynote] ”
&quot;[^keynote]: 这个是注解&quot;
</code></pre><p>这个注解的方式就是Key-Value的形式，他会被markdown解析成注解的样式。</p>
<p>解释完作者的名言我们要开始引用代码进行讲解了：</p>
<pre><code>“    使用四个空格来表示代码块”
</code></pre><p>这种用法主要是对于一些简单的代码进行表示和处理，或者也可以理解为一个文字区块，但是在这个区块中写道的一些特殊命令，markdown会按原文翻译，不会转述成他所表示的形式显示出来。如果有大量的代码要写的话，建议用下面的形式表示：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体的代码</span><br></pre></td></tr></table></figure>
</code></pre><p>这种格式支持40多种语言，基本上满足了我们的需求。</p>
<p>引用完代码之后，我们需要对代码进行解释，在解释的时候我们需要对重要的词句进行加粗（使用<code>“**被加粗的文字**”</code>），或者用斜体（使用<code>“*需要斜体表示的文字*”</code>）进行强调。<br>在讲解时我们肯定会引入别的类名，这时需要用“ <code>`类名</code> ` ”来表示类名，这样就表示是文字内代码。</p>
<p>对于一些比较复杂的逻辑，我们在解释可能会引入一些公式定理来解释，我们可以使用“$v=s/t$”来在行内表示公式定理，如果一整行都是公式定理，我们可以使用“$$整行公式$$”来表示。</p>
<p>在我们介绍这个架构时，会有一些典型的错误，但是我们不希望不仔细的读者将它看成正确的例子，我们可以使用“<del>反例</del>”对中间的文字加上删除线，加以警示。</p>
<p>假如我们写这篇文章时候，是和别人合作的，我们可以在最后用一个表格来表示，这个骗文章的作者，以及每个人写的部分，还有字数等信息。表格的写法如下：</p>
<pre><code>|     作者     |      所写章节      |      字数      |
|     --      |          --:      |      :--:     |    
|     Ted     |      a.b.c章      |     1000字     |
|     Annie   |      d.e.f章      |     1024字     |

注意此部分，&quot;-&quot;的个数无所谓，但是至少一个
</code></pre><p>上述中，“作者”column将会居左，“所写章节”column会居右，“字数”column会居中显示。</p>
<p>好了，文章完成了，我们可以使用[TOC]来给文章加个目录，并且可以使用<br>Tags（标签）：标签1 标签2 标签3    来给文章加上标签。</p>
<p>OK，文章可以发表了！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 TedYin
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>